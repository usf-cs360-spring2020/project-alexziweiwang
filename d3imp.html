<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">

    <title>Final Impelementation Page</title>

    <!-- Load Bulma from CDN (consider saving it to repository instead) -->
    <!-- https://bulma.io/ -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bulma@0.8.0/css/bulma.min.css">

    <!-- Load Font Awesome 5 (free) icons -->
    <script defer src="https://use.fontawesome.com/releases/v5.3.1/js/all.js"></script>


    <style>

  #ResetButton {
    font-size: 12px;
  }

  #YearIntercalSelectButton {
    font-size: 16px;
  }
  #MaterialTypeSelectButton {
    font-size: 16px;
  }
  #queryButton {
    font-size: 16px;
  }

  .axis {
    font: 16px sans-serif;
  }
  #tooltip {
    font-weight: 600;
    text-shadow: 0px 0px 2px white;

    fill: orange;
    stroke: black;
  }

  path.land {
    fill: #dddddd;
    stroke: none;
  }

  path.neighborhood {
    fill: none;
    stroke: white;
    stroke-width: 3.5px;
    pointer-events: none;
  }

  path.street {
    fill: none;
    stroke: white;
    stroke-width: 1px;
    pointer-events: none;
  }

  .active {
    stroke: orange !important;
    stroke-width: 1.5px !important;
  }

  circle.symbol {
    fill-opacity: 0.8;

    stroke: white;
    stroke-width: 1px;
  }

  th {
    text-align: right;
  }


 </style>

</head>

  <body>

  <!-- Page header -->
  <!-- https://bulma.io/documentation/layout/hero/ -->
  <section class="hero is-info is-bold">
    <div class="hero-body">
      <div class="container">
        <h1 class="title">Final Impelementation Page</h1>
        <h2 class="subtitle">Visualization in d3.js</h2>
      </div>
    </div>
  </section>
  <!-- End page header -->

  <!-- Page navigation -->
  <!-- https://bulma.io/documentation/components/navbar/ -->
  <nav class="navbar is-light" role="navigation" aria-label="main navigation">
    <div class="container">
      <div class="navbar-brand">
        <a class="navbar-item is-active" href="index.html">
          <span class="icon"><i class="fas fa-home"></i></span>
          <span>Home</span>
        </a>

        <a role="button" class="navbar-burger burger" aria-label="menu" aria-expanded="false" data-target="main-menu">
          <span aria-hidden="true"></span>
          <span aria-hidden="true"></span>
          <span aria-hidden="true"></span>
        </a>
      </div>

      <div id="main-menu" class="navbar-menu has-text-weight-medium">
        <!-- Left navbar items -->
        <div class="navbar-start">
          <a class="navbar-item" href="dts.html" title="Data">
            <span class="icon"><i class="fas fa-table"></i></span>
            <span>Data</span>
          </a>

          <div class="navbar-item has-dropdown is-hoverable">
            <a class="navbar-link">
              Visualizations
            </a>

            <div class="navbar-dropdown">
              <a class="navbar-item" href="pttpAlpha.html">
                <span class="icon"><i class="fas fa-chart-line"></i></span>
                <span>Prototype-Alpha: non-proportional symbol map in Tableau</span>
              </a>

              <a class="navbar-item" href="pttpBeta2.html">
                <span class="icon"><i class="fas fa-chart-line"></i></span>
                <span>Prototype-Beta-OverallMap: non-proportional symbol map in d3.js</span>
              </a>

              <a class="navbar-item" href="d3imp.html">
                <span class="icon"><i class="fas fa-chart-line"></i></span>
                <span>Final Visualization</span>
              </a>

            </div>
          </div>
        </div>

        <!-- Right navbar items -->
        <div class="navbar-end">
          <a class="navbar-item" href="abt.html" title="About">
            <span class="icon"><i class="fas fa-info-circle"></i></span>
            <span>About</span>
          </a>
        </div>
      </div>
    </div>
  </nav>
  <!-- End page navigation -->

  <section class="section">
    <div class="container">
      <!-- Begin page content -->
      <div class="content">

        <h1 class="title">
          Visualization in d3.js
        </h1>

        <meta charset="utf-8">
        <figure>
          <svg width="1260" height="600" id="vis">
            <g id="basemap"></g>

            <!-- turn off pointer events for certain groups -->
            <g id="streets" pointer-events="none"></g>
            <g id="outline" pointer-events="none"></g>

            <g id="artItems"></g>
            <g id="tooltip" pointer-events="none"></g>
            <g id="details" pointer-events="none"></g>
          </svg>
          <p font-size = "30px">
              <button id="ResetButton" onclick="restButtonClicker()">reset</button>
              Filtering options:
              <select id="YearIntercalSelectButton"></select>
              <select id="MaterialTypeSelectButton"></select>
          <button id="queryButton" onclick="queryButtonClicked()">check art items on the map</button>

        </p>

          <figcaption>
            Source: <a href="https://data.sfgov.org/Culture-and-Recreation/Civic-Art-Collection/7rjr-9n9w">Civic Art Collection</a>
            (<a href="https://data.sfgov.org/Geographic-Locations-and-Boundaries/Analysis-Neighborhoods/p5b7-5n3h">Neighborhoods</a>, <a href="https://data.sfgov.org/Geographic-Locations-and-Boundaries/Streets-Active-and-Retired/3psu-pn9h">Streets</a>)
          </figcaption>
        </figure>

        <script src="https://d3js.org/d3.v5.min.js"></script>

<script>





// configuration of svg/plot area
let config = {
  'svg': {},
  'margin': {},
  'plot': {}
};

config.svg.height = 800;
config.svg.width = 1200; // golden ratio

config.margin.top = 10;
config.margin.right = 30;
config.margin.bottom = -50;
config.margin.left = 160;

config.plot.x = config.margin.left;
config.plot.y = config.margin.top + 630;
config.plot.width = config.svg.width - config.margin.left - config.margin.right;
config.plot.height = config.svg.height - config.margin.top - config.margin.bottom - 720;

// setup svg
let svg = d3.select("body").select("svg#vis");
svg.attr('width', config.svg.width);
svg.attr('height', config.svg.height);

// setup plot area
let plot = svg.append('g');
plot.attr('id', 'plot');
plot.attr('transform', translate(config.plot.x, config.plot.y));

// use a rect to illustrate plot area
let rect = plot.append('rect');
rect.attr('id', 'background');

rect.attr('x', 0);
rect.attr('y', 0);
rect.attr('width', config.plot.width);
rect.attr('height', config.plot.height);

// scales for data
let scale = {};

scale.x = d3.scaleBand();
scale.x.range([0, config.plot.width]);

scale.y = d3.scaleBand();
scale.y.range([config.plot.height, 0]);

// https://github.com/d3/d3-scale-chromatic
scale.color = d3.scaleSequential(d3.interpolateYlGnBu);

let axis = {};  // axes for data
axis.x = d3.axisBottom(scale.x);
axis.x.tickPadding(0);

axis.y = d3.axisLeft(scale.y);
axis.y.tickPadding(0);

let bcScale = {};
let bcAxis = {};
let bx, by;

          const urls = {
            basemap: "https://data.sfgov.org/resource/xfcw-9evu.geojson",
            streets: "https://data.sfgov.org/resource/3psu-pn9h.geojson?$limit=8000",
            artItems: "https://data.sfgov.org/resource/7rjr-9n9w.json"
          };

          // calculate date range
          const end = d3.timeDay.floor(d3.timeDay.offset(new Date(), -1));
          const start = d3.timeDay.floor(d3.timeDay.offset(end, -7));
          const format = d3.timeFormat("%Y-%m-%dT%H:%M:%S");
          console.log(format(start), format(end));

          urls.artItems = 'https://data.sfgov.org/resource/7rjr-9n9w.json';

          console.log(urls.artItems);

          const g = {
            edgeBunddling: svg.select("g#edgeBunddling"),
            basemap: svg.select("g#basemap"),
            streets: svg.select("g#streets"),
            outline: svg.select("g#outline"),
            artItems: svg.select("g#artItems"),
            tooltip: svg.select("g#tooltip"),
            details: svg.select("g#details")
          };

          let matExactMap = {};
          let mTypeMap = {};
          let materialSet = new Set();
          let nodes = new Set();
          let original = [];
          let processed = [];
          let timeMap = {};
          let YIMTmap = {};
          initializeYIMTmap();
          timeMap['architectural material'] = [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0];
          timeMap['metal'] = [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0];
          timeMap['mineral'] = [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0];
          timeMap['ecological'] = [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0];
          timeMap['daily life object']  = [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0];
          timeMap['kiln product'] = [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0];
          let rawDataPlatTableArr = [];
          let res = [];

          nodes.add('root');
          nodes.add('metal');
          nodes.add('mineral');
          nodes.add('ecological');
          nodes.add('daily life object');
          nodes.add('architectural material');
          nodes.add('kiln product');
          let typeName = ['architectural material', 'metal', 'mineral', 'ecological', 'daily life object', 'kiln product'];
          let yearInterval = ['1811-1835', '1836-1860', '1861-1885', '1886-1910', '1911-1935',
        '1936-1960', '1961-1985', '1986-2010', '2011-2035', 'unknown year'];
          //0: 1811-1835
          //1: 1836-1860
          //2: 1861-1885
          //3: 1886-1910
          //4: 1911-1935
          //5: 1936-1960
          //6: 1961-1985
          //7: 1986-2010
          //8: 2011-2035
          let yearIntervaoOptions = ['Select a year interval','all','1811-1835', '1836-1860', '1861-1885', '1886-1910', '1911-1935',
        '1936-1960', '1961-1985', '1986-2010', '2011-2035','unknown year'];
          var optionYI = d3.select("#YearIntercalSelectButton")
            .selectAll('myOptions')
            .data(yearIntervaoOptions)
            .enter()
            .append('option')
            .text(function (d) { return d; }) // text showed in the menu
            .attr("value", function (d) { return d; }) // corresponding value returned by the button

          let MaterialTypeOptions = ['Select a material type','all','architectural material', 'metal', 'mineral', 'ecological', 'daily life object', 'kiln product'];
          var optionMT = d3.select("#MaterialTypeSelectButton")
            .selectAll('myOptions')
            .data(MaterialTypeOptions)
            .enter()
            .append('option')
            .text(function (d) { return d; }) // text showed in the menu
            .attr("value", function (d) { return d; }) // corresponding value returned by the button
//'Select a year interval'  'Select a material type'
          let YearChosen = 'all';
          let MTypeChosen = 'all';
          let hmChosen = false;


          let metalSet = new Set(["bronze", "steel", "gold leaf", "brass", "aluminum", "zinc", "copper", "bronzing powder", "metal", "copper leaf", "iron", "gold"]);
          let mineralSet = new Set(["marble","granite", "terrazzo", "stone tiles", "cast stone", "soil", "lava rock", "stone", "basalt", "travertine", "graphite", "tesserae", "tuff stone", "stone boulder", "charcoal", "mortar",
          "crystals", "minerals", "red porphyry", "onyx"]);
          let ecoSet = new Set(["wood", "bone", "horn", "resin", "cotton", "plant", "oil", "wool", "planted earthwork", "wax", "bamboo", "ecological references", "water", "willow", "tule reed"]);

          let dailyLifeSet = new Set(["loudspeakers","images","ink", "cables", "mirror", "video", "magnets", "electrical reed switches"
          , "photogram", "wire", "egg tempera", "aero plate", "audiobox","electrical wiring",
          "pencil", "paper", "digital print", "buttons", "jewelry", "recycled parking meter heads", "brass saxophones", "steel music panels", "shade cloth", "controller", "motors","electronics","recycled mirrors", "annotated library cards"]);

          let architectureSet = new Set(["pigments","plastic mixture","paint", "mixed medium","plastic","led lighting","slate", "lighting", "asphalt","unknown", "mixed media relief","painted mural", "linoleum", "pigment", "architectural foam", "pigment print", "pastel", "archival pigment print", "cast aggregate", "mixed media color lino-cut print", "lacquer paint", "foam", "fabric collage", "soffits", "land scaping", "lino-cut print", "cement", "polyurethane foam",
          "found objects", "plaster", "fresco", "concrete", "mixed media", "neon lighting", "argon lighting", "fluorescent lighting", "lacquer paints", "mirror tile", "abaca paper", "ink with gesso", "led", "mural",
          "photography", "brick", "pipes", "polymer modified gypsum", "sisal rope"]);

          let kilnSet = new Set(["glaze","ceramic beads","porcelain enamel","porcelain", "ceramic tile", "clay", "glass", "cast glass", "frosted glass", "mosaic tile", "enamel", "ceramic", "gilding", "enamel paint", "terracotta tile", "glass tiles", "glazed ceramic"
          ,"crockery", "grout", "basaltic clay", "glass mosaic tile", "gfrc tile", "tile", "glass mosaic", "laminated digital print", "polyurethane paint"]);

          const csvMat = "artcommision_categorized_material - Civic_Art_Collection.csv";
          d3.csv(csvMat, recordMaterialInfo).then(makeDataFormat).then(drawAxis).then(drawHeatmap);
        //.then(drawTitleCaptions);

          function recordMaterialInfo(row) {
            var materials = row.MediumMaterial;

            var matArr = materials.split(",");
            if(materials.length != 0) {
              index = 0;
              while (index < matArr.length) {
                temp = matArr[index];
                temp = temp.trim();
                temp = temp.toLowerCase();
                if(temp == "" || temp.length < 1) {
                  temp = "unknown";
                }
                materialSet.add(temp);

                artist = row.Artist;
                date = row.CreationFinishDate;
                acsNumber = row.AccessionNumber;
                mediumDetail = row.MediumDetail;
                displayTitle = row.DisplayTitle;
                latitude = row.Latitude;
                longitude = row.Longitude;
                nbh = row.SFFindNeighborhoods;

                //metalSet, mineralSet, ecoSet, dailyLifeSet, architectureSet, kilnSet
                timeArrIndex = getTimeIntervalIndex(date);
                currYearInterval = yearInterval[timeArrIndex];

                if(metalSet.has(temp)) {
                  mType = "metal";
                } else if(mineralSet.has(temp)) {
                  mType = "mineral";
                } else if(ecoSet.has(temp)) {
                  mType = "ecological";
                } else if(dailyLifeSet.has(temp)) {
                  mType = "daily life object";
                } else if(architectureSet.has(temp)) {
                  mType = "architectural material";
                } else if(kilnSet.has(temp)) {
                  mType = "kiln product";
                } else {
                  console.log("not having: ");
                  console.log(temp);
                }

                setAllMT = YIMTmap['allYI']['all mType'];
                setAllMT.add(acsNumber);
                setAllYI = YIMTmap['allYI'][mType];
                setAllYI.add(acsNumber);
                setCurrYI = YIMTmap[currYearInterval][mType];
                setCurrYI.add(acsNumber);
                setCurrYIallMT = YIMTmap[currYearInterval]['all mType'];
                setCurrYIallMT.add(acsNumber);

                listTimeCount = timeMap[mType][timeArrIndex];
                listTimeCount ++;
                timeMap[mType][timeArrIndex] = listTimeCount;

                if(matExactMap[temp]) {

                  currMatList = matExactMap[temp];
                  currMatList.push({
                    'Material': temp,
                    'Artist': artist,
                    'Completion Year': date,
                    'Accession Number': acsNumber,
                    'MediumDetail': mediumDetail,
                    'DisplayTitle': displayTitle,
                    'Latitude': latitude,
                    'Longitude': longitude,
                    'Material Type': mType,
                    'Year Interval': currYearInterval
                  });
                  matExactMap[temp] = currMatList;
                } else {
                  currMatList = [];

                  currMatList.push({
                    'Material': temp,
                    'Artist': artist,
                    'Completion Year': date,
                    'Accession Number': acsNumber,
                    'MediumDetail': mediumDetail,
                    'DisplayTitle': displayTitle,
                    'Latitude': latitude,
                    'Longitude': longitude,
                    'Material Type': mType,
                    'Year Interval': currYearInterval
                  });
                  matExactMap[temp] = currMatList;
                }

                if(mTypeMap[mType]) {
                  typeSubMap = mTypeMap[mType];
                  if(typeSubMap[temp]) {
                    itemList = typeSubMap[temp];
                    itemList.push({
                      'Material': temp,
                      'Artist': artist,
                      'Completion Year': date,
                      'Accession Number': acsNumber,
                      'MediumDetail': mediumDetail,
                      'DisplayTitle': displayTitle,
                      'Latitude': latitude,
                      'Longitude': longitude,
                      'Material Type': mType,
                      'Year Interval': currYearInterval
                    })
                    typeSubMap[temp]= itemList;
                  } else {
                    itemList = [];
                    itemList.push({
                      'Material': temp,
                      'Artist': artist,
                      'Completion Year': date,
                      'Accession Number': acsNumber,
                      'MediumDetail': mediumDetail,
                      'DisplayTitle': displayTitle,
                      'Latitude': latitude,
                      'Longitude': longitude,
                      'Material Type': mType,
                      'Year Interval': currYearInterval
                    })
                    typeSubMap[temp]= itemList;

                  }
                  mTypeMap[mType] = typeSubMap;

                } else {
                  typeSubMap = {};

                  itemList = [];
                  itemList.push({
                    'Material': temp,
                    'Artist': artist,
                    'Completion Year': date,
                    'Accession Number': acsNumber,
                    'MediumDetail': mediumDetail,
                    'DisplayTitle': displayTitle,
                    'Latitude': latitude,
                    'Longitude': longitude,
                    'Material Type': mType,
                    'Year Interval': currYearInterval

                  })
                  typeSubMap[temp] = itemList;
                  mTypeMap[mType] = typeSubMap;
                }


                index++;
              }
            }
            rawDataPlatTableArr.push({
              'Artist': artist,
              'Completion Year': date,
              'Accession Number': acsNumber,
              'MediumDetail': mediumDetail,
              'DisplayTitle': displayTitle,
              'Latitude': latitude,
              'Longitude': longitude,
              'Material Type': mType,
              'Year Interval': currYearInterval
            })
            return materialSet;

          }

          function initializeYIMTmap() {
  //          ['1811-1835', '1836-1860', '1861-1885', '1886-1910', '1911-1935', '1936-1960', '1961-1985', '1986-2010', '2011-2035', 'unknown year']
            YIMTmap['allYI'] = initializeMTacsSubMap();
            YIMTmap['1811-1835'] = initializeMTacsSubMap();
            YIMTmap['1836-1860'] = initializeMTacsSubMap();
            YIMTmap['1861-1885'] = initializeMTacsSubMap();
            YIMTmap['1886-1910'] = initializeMTacsSubMap();
            YIMTmap['1911-1935'] = initializeMTacsSubMap();
            YIMTmap['1936-1960'] = initializeMTacsSubMap();
            YIMTmap['1961-1985'] = initializeMTacsSubMap();
            YIMTmap['1986-2010'] = initializeMTacsSubMap();
            YIMTmap['2011-2035'] = initializeMTacsSubMap();
            YIMTmap['unknown year'] = initializeMTacsSubMap();
            console.log("Completed YIMTmap: ");
            console.log(YIMTmap);
          }

          function initializeMTacsSubMap() {
            //typeName = ['architectural material', 'metal', 'mineral', 'ecological', 'daily life object', 'kiln product'];

            MTacsSubMap = {};
            MTacsSubMap['all mType'] = new Set();
            MTacsSubMap['architectural material'] = new Set();
            MTacsSubMap['metal'] = new Set();
            MTacsSubMap['mineral'] = new Set();
            MTacsSubMap['ecological'] = new Set();
            MTacsSubMap['daily life object'] = new Set();
            MTacsSubMap['kiln product'] = new Set();

            return MTacsSubMap;
          }


          function makeDataFormat(data) {
            console.log('materialSet: ');
            console.log(materialSet);
            console.log('mTypeMap: ');
            console.log(mTypeMap);
            console.log('timeMap: ');
            console.log(timeMap);
            console.log('rawDataPlatTableArr: ');
            console.log(rawDataPlatTableArr);
            console.log("Completed YIMTmap: ");
            console.log(YIMTmap);

//metalSet, mineralSet, ecoSet, dailyLifeSet, architectureSet, kilnSet
            allCount = 0; //count of leaves

            archName = 'architectural material';
            typeCount = recordOneType(architectureSet, matExactMap, original, nodes, archName);
            allCount = allCount + typeCount;

            metalName = "metal";
            typeCount = recordOneType(metalSet, matExactMap, original, nodes, metalName);
            allCount = allCount + typeCount;

            mineralName = "mineral";
            typeCount = recordOneType(mineralSet, matExactMap, original, nodes, mineralName);
            allCount = allCount + typeCount;

            ecoName = "ecological";
            typeCount = recordOneType(ecoSet, matExactMap, original, nodes, ecoName);
            allCount = allCount + typeCount;

            dailyName = "daily life object";
            typeCount = recordOneType(dailyLifeSet, matExactMap, original, nodes, dailyName);
            allCount = allCount + typeCount;

            kilnName = "kiln product";
            typeCount = recordOneType(kilnSet, matExactMap, original, nodes, kilnName);
            allCount = allCount + typeCount;

            console.log(allCount);

            i = 0;
            while(i < 6) {
              let oneRow = {};
              oneRow.values = [];
              count = 0;
              type = typeName[i];
              oneRow['type'] = type;

              while(count < 10) {
                oneRow.values.push({
                  'yearInterval': yearInterval[count],
                  'itemCount': timeMap[type][count],
                  'index': i
                })
                count ++;
              }

              res[i] = oneRow;
              i ++;
            }

            console.log(res);
            return res;
}


function drawAxis(data) {

       console.log(data);

       // now that we have data set the scale domain
       scale.x.domain(yearInterval);
       scale.y.domain(typeName);

       // draw the x and y axis
       let gx = svg.append('g');
       gx.attr("id", "x-axis");
       gx.attr("class", "axis");
       plotX = config.plot.x;
       plotYH = config.plot.y + config.plot.height;

       gx.attr('transform', translate(plotX, plotYH));
       gx.call(axis.x);

       let gy = svg.append('g');
       gy.attr("id", "y-axis");
       gy.attr("class", "axis");

       plotY = config.plot.y;

       gy.attr('transform', translate(config.plot.x, config.plot.y));
       gy.call(axis.y);

       // add the options to the button

       return data;
     }


     function drawHeatmap(data) {
        //let typeName = ['architectural material', 'metal', 'mineral', 'ecological', 'daily life object', 'kiln product'];

        allValues = timeMap['architectural material'].concat(timeMap['metal'],
      timeMap['mineral'], timeMap['ecological'], timeMap['daily life object'], timeMap['kiln product'])

        allValues.sort((a,b)=>a-b);
        console.log(allValues);
        let min = d3.quantile(allValues, 0);
        let q1 = d3.quantile(allValues, 0.25);
        let median = d3.quantile(allValues, 0.5);
        let q3 = d3.quantile(allValues, 0.75);
        let max = d3.quantile(allValues, 1);

   //        scale.color.domain([min, q1, median, q3, max]);
   scale.color.domain([0, d3.max(allValues)]);

        // create one group per row
        let rows = plot.selectAll("g.cell")
               .data(data)
               .enter()
               .append("g");
             rows.attr("class", "cell");
             rows.attr("transform", function(d) {
               return translate(0, scale.y(d['type']));
             });

             let cells = rows.selectAll("rect")
               .data(d => d.values)
               .enter()
               .append("rect");

             cells.attr("x", d => scale.x(d.yearInterval));
             cells.attr("y", 0); // handled by group transform
             cells.attr("width", scale.x.bandwidth());
             cells.attr("height", scale.y.bandwidth());
             cells.style("stroke", "silver");
             cells.style("stroke-width", 0.5);

             // here is the color magic!
             cells.style("fill", d => scale.color(d.itemCount));

             cells.on("mouseover", function(d) {
                 let text = "Number of Art Item: " + d.itemCount;

                 // create tooltip
                 let tooltip = svg.append('text')
                    .text(text)
                    .attr('x', 300)
                    .attr('y', 792)
                    .attr('text-anchor', 'middle') // anchor in the middle
                    .attr('id', 'tooltip')
                    .attr("font-weight",300)
                    .style('fill', 'midnightblue');

                    cells.filter(e => (d.yearInterval !== e.yearInterval)).style("fill-opacity", "0.6");
                    cells.filter(e => (d.yearInterval !== e.yearInterval)).style("stroke", "#e5e5e5").style("fill-opacity", "0.6");
                    cells.filter(e => (d.index !== e.index)).style("fill-opacity", "0.6");
                    cells.filter(e => (d.index !== e.index)).style("stroke", "#e5e5e5").style("fill-opacity", "0.6");
                    cells.style("stroke", "silver");
             });

             cells.on("mouseout", function(d) {
                    d3.selectAll("#tooltip").remove();
                    cells.style("stroke", "silver");
                    cells.style("stroke-width", 0.5);
                    cells.style("fill", d => scale.color(d.itemCount)).style("fill-opacity", "1");
             });

             cells.on("click", function(d) {

                 YearChosen = d.yearInterval;
                 MTypeChosen = typeName[d.index];
                 optionYI.property("selected", function(d) {
                   if(YearChosen == 'unknown') {
                     YearChosen = 'unknown year';
                   }
                   return d === YearChosen;
                 });

                 optionMT.property("selected", function(d) {
                   return d === MTypeChosen;
                 });

                 console.log("hm: year: " + YearChosen);
                 console.log("hm: material type: " + MTypeChosen);

             });

           }


function restButtonClicker() {
  //'Select a year interval'  'Select a material type'
  optionYI.property("selected", function(d) {
    YearChosen = 'all';
    return d === 'Select a year interval';
  });

  optionMT.property("selected", function(d) {
    MTypeChosen = 'all';
    return d ==='Select a material type';
  });
}


function queryButtonClicked() {
    //YearIntercalSelectButton
    //MaterialTypeSelectButton
    requirement = [];

    console.log("query button clicked!!");

      d3.select("#YearIntercalSelectButton").on("change", function(d) {
        var selectedYear = d3.select(this).property("value");
        if(selectedYear == 'Select a year interval') {
          YearChosen = 'all';
        } else {
          YearChosen = selectedYear;
        }
        console.log("op CHANGED: year: " + YearChosen);

      })


      d3.select("#MaterialTypeSelectButton").on("change", function(d) {
        var selectedMType = d3.select(this).property("value");
        if(selectedMType == 'Select a material type') {
          MTypeChosen = 'all';
        } else {
          MTypeChosen = selectedMType;
        }
        console.log("op CHANGED: material type: " + MTypeChosen);

     })

console.log("op: year: " + YearChosen);
console.log("op: material type: " + MTypeChosen);
    requirement[0] = YearChosen;
    requirement[1] = MTypeChosen;
    d3.json(urls.artItems).then(drawArtItems);
    return requirement
}

function recordOneType(typeSet, matExactMap, original, nodes, typeName) {
  typeCount = 0;
  typeSetSize = typeSet.size;
  var typeItr = typeSet.entries();
  for(i=0;i<typeSetSize;i++){
    exactMaterial = typeItr.next().value[0];
    nodes.add(exactMaterial);

    exactList = [];
    exactList = matExactMap[exactMaterial];
//         console.log(exactMaterial);
//          console.log(exactList);

    original.push({
      'name' : exactMaterial,
      'count' : exactList.length,
      'leave' : 1
    })
    typeCount ++;
  }
  original.push({
    'name' : typeName,
    'count' : typeCount,
    'leave' : typeCount
  })

  return typeCount;
}

function getTimeIntervalIndex(year) {
  //every 25 years
  //0: 1811-1835
  //1: 1836-1860
  //2: 1861-1885
  //3: 1886-1910
  //4: 1911-1935
  //5: 1936-1960
  //6: 1961-1985
  //7: 1986-2010
  //8: 2011-2035
  var yearValue = parseInt(year);

  var diff = yearValue - 1811;
  if(diff < 25) {
    return 0; //0: 1811-1835
  } else if(diff >= 25 && diff < 50){
    return 1; //1: 1836-1860
  } else if(diff >= 50 && diff < 75) {
    return 2; //2: 1861-1885
  } else if (diff >= 75 && diff < 100) {
    return 3; //3: 1886-1910
  } else if(diff >= 100 && diff < 125) {
    return 4;
  } else if(diff >= 125 && diff < 150) {
    return 5;
  } else if (diff >= 150 && diff < 175) {
    return 6;
  } else if (diff >= 175 && diff < 200) {
    return 7;
  } else if (diff >= 200 && diff < 225) {
    return 8;
  }

  return 9; //8 is for unkown year...

}


          function line() {
            d3.lineRadial()
              .curve(d3.curveBundle.beta(0.85))
              .radius(d => d.y)
              .angle(d => d.x)
          }

          function id(node) {
            return `${node.parent ? id(node.parent) + "." : ""}${node.data.name}`;
          }

          const tip = g.tooltip.append("text").attr("id", "tooltip");
          tip.attr("text-anchor", "end");
          tip.attr("dx", -5);
          tip.attr("dy", -5);
          tip.style("visibility", "hidden");

          // add details widget
          // https://bl.ocks.org/mbostock/1424037
          const details = g.details.append("foreignObject")
            .attr("id", "details")
            .attr("width", 500)
            .attr("height", 500)
            .attr("x", 700)
            .attr("y", 120);

          const body = details.append("xhtml:body")
            .style("text-align", "left")
            .style("background", "none")
            .html("<p>N/A</p>");

          details.style("visibility", "hidden");

          // setup projection
          // https://github.com/d3/d3-geo#geoConicEqualArea
          const projection = d3.geoConicEqualArea();
          projection.parallels([37.692514, 37.840699]);
          projection.rotate([122, 0]);

          // setup path generator (note it is a GEO path, not a normal path)
          const path = d3.geoPath().projection(projection);

          d3.json(urls.basemap).then(function(json) {
            // makes sure to adjust projection to fit all of our regions
            projection.fitSize([960, 600], json);

            // draw the land and neighborhood outlines
            drawBasemap(json);

            // now that projection has been set trigger loading the other files
            // note that the actual order these files are loaded may differ
            d3.json(urls.streets).then(drawStreets);
            d3.json(urls.artItems).then(drawArtItems);
          });

          function drawBasemap(json) {
            console.log("basemap", json);

            const basemap = g.basemap.selectAll("path.land")
              .data(json.features)
              .enter()
              .append("path")
              .attr("d", path)
              .attr("class", "land");

            const outline = g.outline.selectAll("path.neighborhood")
                .data(json.features)
                .enter()
                .append("path")
                .attr("d", path)
                .attr("class", "neighborhood")
                .each(function(d) {
                  // save selection in data for interactivity
                  // saves search time finding the right outline later
                  d.properties.outline = this;
                });

            // add highlight
            basemap.on("mouseover.highlight", function(d) {
              d3.select(d.properties.outline).raise();
              d3.select(d.properties.outline).classed("active", true);
            })
            .on("mouseout.highlight", function(d) {
              d3.select(d.properties.outline).classed("active", false);
            });

            // add tooltip
            basemap.on("mouseover.tooltip", function(d) {
              tip.text(d.properties.nhood);
              tip.style("visibility", "visible");
            })
            .on("mousemove.tooltip", function(d) {
              const coords = d3.mouse(g.basemap.node());
              tip.attr("x", coords[0]);
              tip.attr("y", coords[1]);
            })
            .on("mouseout.tooltip", function(d) {
              tip.style("visibility", "hidden");
            });
          }

          function drawStreets(json) {
            console.log("streets", json);

            // only show active streets
            const streets = json.features.filter(function(d) {
              return d.properties.active;
            });

            console.log("removed", json.features.length - streets.length, "inactive streets");

            g.streets.selectAll("path.street")
              .data(streets)
              .enter()
              .append("path")
              .attr("d", path)
              .attr("class", "street");
          }

          function drawArtItems(json) {
            d3.selectAll("#allSymbols").remove();
            console.log(json);
            //if specific requirement, change set, otherwise use the default set...
            //according to queryReq, change the set range/content
            let acsSet = new Set();
            if (YearChosen == 'all') {
              if(MTypeChosen == 'all') {
                acsSet = YIMTmap['allYI']['all mType'];
              } else {
                acsSet = YIMTmap['allYI'][MTypeChosen];
              }
            } else {
              if(MTypeChosen == 'all') {
                acsSet = YIMTmap[YearChosen]['all mType'];
              } else {
                acsSet = YIMTmap[YearChosen][MTypeChosen];
              }
            }
            console.log("!!!!!!!!!!!!!!!!!!!!!!!current range: ");
            console.log(YearChosen + ", " + MTypeChosen +": ");
            console.log(acsSet);

            // loop through and add projected (x, y) coordinates
            // (just makes our d3 code a bit more simple later)
            count = 0;
            json.forEach(function(d) {
              if(!isNaN(d.latitude) && !isNaN(d.longitude)) {
                count++;
                const latitude = parseFloat(d.latitude);
                const longitude = parseFloat(d.longitude);
                const pixels = projection([longitude, latitude]);

                d.x = pixels[0];
                d.y = pixels[1];
              } else {
                d.x = -10;
                d.y = -10;
              }
            });

            const symbols = g.artItems.selectAll("circle")
              .data(json)
              .enter()
              .filter(d => (acsSet.has(d.accession_number)))
              .append("circle")
              .attr("id", "allSymbols")
              .attr("cx", function(d) { if(!isNaN(d.x))return d.x;})
              .attr("cy", function(d) { if(!isNaN(d.y))return d.y;})
              .attr("r", 5)
              .attr("class", "symbol");
    //        symbols.style("fill", "black");
      //      symbols.filter(d => (acsSet.has(d.AccessionNumber))).style("fill", "pink");
      //      console.log(d.AccessionNumber);


/*
            symbolChosen = false;
            symbols.on("click", function(d) {
                symbols.style("fill", "black");

                if(symbolChosen == false) {
                  console.log('clicking symbol... ' + d.artist);
                  symbols.filter(e => (acsSet.has(e.AccessionNumber))).style("fill", "pink");
                  if(acsSet.has(d.AccessionNumber)) {
                    console.log("???");
                  }

                  symbolChosen = true;
                } else {
                  symbols.style("fill", "black");
                  symbolChosen = false;
                }
            });
*/

            symbols.on("mouseover", function(d) {
              d3.select(this).raise();
              d3.select(this).classed("active", true);

              // use template literal for the detail table
              // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Template_literals
              const html = `
                <table border="0" cellspacing="0" cellpadding="2">
                <tbody>
                <tr>
                  <th>Accession Number:</th>
                  <td>${d.accession_number}</td>
                </tr>
                <tr>
                  <th>Display Title:</th>
                  <td>${d.display_title}</td>
                </tr>
                <tr>
                  <th>Artist:</th>
                  <td>${d.artist}</td>
                </tr>
                <tr>
                  <th>Creation Date:</th>
                  <td>${d.creation_date}</td>
                </tr>
                <tr>
                  <th>Medium:</th>
                  <td>${d.medium}</td>
                </tr>
                <tr>
                  <th>Media & Support:</th>
                  <td>${d.media_support}</td>
                </tr>

              </tbody>
              </table>`;

              body.html(html);
              details.style("visibility", "visible");
            });

            symbols.on("mouseout", function(d) {

      //        symbols.style("fill", "black");

              d3.select(this).classed("active", false);
              details.style("visibility", "hidden");
            });

          }

          function translate(x, y) {
            return "translate(" + String(x) + "," + String(y) + ")";
          }


</script>


        <h3>Question: </h3>
        <p> Is there any clustering of artists that use similar materials as medium of art items and how are the artists connected to each other by such similarity?</p>

        <h3>Answer: </h3>
        <p> We might need further data visualization to answer the question, since symbols on the map would be hard to see relationships like connections among them.</p>

        <h3>Encoding: </h3>
        <p> In this map visualization, each symbol on the map represents the position of an art item. When hovering on a symbol, the pink on symbols means those art items are created by the same artist; when clicking on a symbol, all symbol with art item made from same materials as medium would remain.
        </p>

        <h3>Interactivity: </h3>
        <p> If the user choose to see a type of medium(material) or an artist on the map, only symbols that are under this category would remain on this geospatial data visualization, and relative edge-bundling graph would also show up for presenting relationships among artists.</p>



      </div>
      <!-- End page content -->
    </div>
  </section>

  <!-- Page footer -->
  <!-- https://bulma.io/documentation/layout/footer/ -->
  <footer class="footer">
    <div class="content has-text-centered is-size-7">
      <p>
        <a href="#top">
          <span class="fas fa-arrow-up"></span>
          <span class="has-text-weight-medium">Back to Top</span>
        </a>
      </p>

      <p>
        <a href="https://github.com/usf-cs360-spring2020/project-alexziweiwang" class="button is-small" style="padding-left: 1em; padding-right: 1em;" target = _blank>
          <i class="fab fa-github-alt"></i>&nbsp;<strong>Github</strong>
        </a>

        <a href="https://fontawesome.com/" class="button is-small" style="padding-left: 1em; padding-right: 1em;">
          <i class="fab fa-font-awesome"></i>&nbsp;<strong>FontAwesome</strong>
        </a>

        <a href="https://bulma.io" class="button is-small">
          <img src="https://bulma.io/images/made-with-bulma--semiblack.png" alt="Made with Bulma" width="128" height="24">
        </a>
      </p>
    </div>
  </footer>
  <!-- End page footer -->
  </body>

</html>
