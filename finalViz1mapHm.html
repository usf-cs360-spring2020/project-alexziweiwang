<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">

    <title>Final Visualization 1: Historial and Geospatial Distribution of Materials in Art Items</title>

    <!-- Load Bulma from CDN (consider saving it to repository instead) -->
    <!-- https://bulma.io/ -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bulma@0.8.0/css/bulma.min.css">

    <!-- Load Font Awesome 5 (free) icons -->
    <script defer src="https://use.fontawesome.com/releases/v5.3.1/js/all.js"></script>


    <style>

  #ResetButton {
    font-size: 12px;
  }

  #YearIntercalSelectButton {
    font-size: 16px;
  }
  #MaterialTypeSelectButton {
    font-size: 16px;
  }
  #queryButton {
    font-size: 16px;
  }

  .axis {
    font: 16px sans-serif;
  }
  #tooltip {
    font-weight: 600;
    text-shadow: 0px 0px 2px white;

    fill: orange;
    stroke: black;
  }

  path.land {
    fill: #dddddd;
    stroke: none;
  }

  path.neighborhood {
    fill: none;
    stroke: white;
    stroke-width: 3.5px;
    pointer-events: none;
  }

  path.street {
    fill: none;
    stroke: white;
    stroke-width: 1px;
    pointer-events: none;
  }

  .active {
    stroke: orange !important;
    stroke-width: 1.5px !important;
  }

  circle.symbol {
    fill-opacity: 0.7;

    stroke: white;
    stroke-width: 1px;
  }

  th {
    text-align: right;
  }


 </style>

</head>

  <body>

  <!-- Page header -->
  <!-- https://bulma.io/documentation/layout/hero/ -->
  <section class="hero is-info is-bold">
    <div class="hero-body">
      <div class="container">
        <h1 class="title">Final Visualization 1: Historial and Geospatial Distribution of Materials in Art Items</h1>
        <h2 class="subtitle">Visualization in d3.js</h2>
      </div>
    </div>
  </section>
  <!-- End page header -->

  <!-- Page navigation -->
  <!-- https://bulma.io/documentation/components/navbar/ -->
  <nav class="navbar is-light" role="navigation" aria-label="main navigation">
    <div class="container">
      <div class="navbar-brand">
        <a class="navbar-item is-active" href="index.html">
          <span class="icon"><i class="fas fa-home"></i></span>
          <span>Home</span>
        </a>

        <a role="button" class="navbar-burger burger" aria-label="menu" aria-expanded="false" data-target="main-menu">
          <span aria-hidden="true"></span>
          <span aria-hidden="true"></span>
          <span aria-hidden="true"></span>
        </a>
      </div>

      <div id="main-menu" class="navbar-menu has-text-weight-medium">
        <!-- Left navbar items -->
        <div class="navbar-start">
          <a class="navbar-item" href="dts.html" title="Data">
            <span class="icon"><i class="fas fa-table"></i></span>
            <span>Data</span>
          </a>

          <div class="navbar-item has-dropdown is-hoverable">
            <a class="navbar-link">
              Visualizations
            </a>

            <div class="navbar-dropdown">
              <a class="navbar-item" href="pttpAlpha.html">
                <span class="icon"><i class="fas fa-chart-line"></i></span>
                <span>Prototype-Alpha: non-proportional symbol map in Tableau</span>
              </a>

              <a class="navbar-item" href="pttpBeta2.html">
                <span class="icon"><i class="fas fa-chart-line"></i></span>
                <span>Prototype-Beta-OverallMap: non-proportional symbol map in d3.js</span>
              </a>

              <a class="navbar-item" href="finalViz1mapHm.html">
                <span class="icon"><i class="fas fa-chart-line"></i></span>
                <span>Final Visualization 1: historial and geospatial distribution of materials in art items</span>
              </a>

              <a class="navbar-item" href="finalViz2Hierarchical.html">
                <span class="icon"><i class="fas fa-chart-line"></i></span>
                <span>Final Visualization 2: hierarchical relationship of types of materials in art items</span>
              </a>



            </div>
          </div>
        </div>

        <!-- Right navbar items -->
        <div class="navbar-end">
          <a class="navbar-item" href="abt.html" title="About">
            <span class="icon"><i class="fas fa-info-circle"></i></span>
            <span>About</span>
          </a>
        </div>
      </div>
    </div>
  </nav>
  <!-- End page navigation -->

  <section class="section">
    <div class="container">
      <!-- Begin page content -->
      <div class="content">

        <h1 class="title">
          Visualization in d3.js
        </h1>

        <meta charset="utf-8">
        <figure>
          <svg width="1260" height="600" id="vis">
            <g id="basemap"></g>

            <!-- turn off pointer events for certain groups -->
            <g id="streets" pointer-events="none"></g>
            <g id="outline" pointer-events="none"></g>

            <g id="artItems"></g>
            <g id="tooltip" pointer-events="none"></g>
            <g id="details" pointer-events="none"></g>
          </svg>
          <p font-size = "30px">
              <button id="ResetButton" onclick="restButtonClicker()">reset</button>
              Filtering options:
              <select id="YearIntercalSelectButton"></select>
              <select id="MaterialTypeSelectButton"></select>
          <button id="queryButton" onclick="queryButtonClicked()">check art items on the map</button></br>
          <a href = "finalViz2Hierarchical.html" target = "_blank">What kind of materials are there in each type? (Click to see more specific material classifications!)</a>

        </p>

          <figcaption>
            Source: <a href="https://data.sfgov.org/Culture-and-Recreation/Civic-Art-Collection/7rjr-9n9w">Civic Art Collection</a>
            (<a href="https://data.sfgov.org/Geographic-Locations-and-Boundaries/Analysis-Neighborhoods/p5b7-5n3h">Neighborhoods</a>, <a href="https://data.sfgov.org/Geographic-Locations-and-Boundaries/Streets-Active-and-Retired/3psu-pn9h">Streets</a>)
          </figcaption>
        </figure>

        <script src="https://d3js.org/d3.v5.min.js"></script>

<script>

// configuration of svg/plot area
let config = {
  'svg': {},
  'margin': {},
  'plot': {}
};

config.svg.height = 800;
config.svg.width = 1440; // golden ratio

config.margin.top = 10;
config.margin.right = 220;
config.margin.bottom = -50;
config.margin.left = 160;

config.plot.x = config.margin.left;
config.plot.y = config.margin.top + 630;
config.plot.width = config.svg.width - config.margin.left - config.margin.right;
config.plot.height = config.svg.height - config.margin.top - config.margin.bottom - 720;

// setup svg
let svg = d3.select("body").select("svg#vis");
svg.attr('width', config.svg.width);
svg.attr('height', config.svg.height);

// setup plot area
let plot = svg.append('g');
plot.attr('id', 'plot');
plot.attr('transform', translate(config.plot.x, config.plot.y));

// use a rect to illustrate plot area
let rect = plot.append('rect');
rect.attr('id', 'background');

rect.attr('x', 0);
rect.attr('y', 0);
rect.attr('width', config.plot.width);
rect.attr('height', config.plot.height);

// scales for data
let scale = {};

scale.x = d3.scaleBand();
scale.x.range([0, config.plot.width]);

scale.y = d3.scaleBand();
scale.y.range([config.plot.height, 0]);

// https://github.com/d3/d3-scale-chromatic
scale.color = d3.scaleSequential(d3.interpolatePurples);


//interpolatePuBuGn


let axis = {};  // axes for data
axis.x = d3.axisBottom(scale.x);
axis.x.tickPadding(0);

axis.y = d3.axisLeft(scale.y);
axis.y.tickPadding(0);


          const urls = {
            basemap: "https://data.sfgov.org/resource/xfcw-9evu.geojson",
            streets: "https://data.sfgov.org/resource/3psu-pn9h.geojson?$limit=8000",
            artItems: "https://data.sfgov.org/resource/7rjr-9n9w.json"
          };

          // calculate date range
          const end = d3.timeDay.floor(d3.timeDay.offset(new Date(), -1));
          const start = d3.timeDay.floor(d3.timeDay.offset(end, -7));
          const format = d3.timeFormat("%Y-%m-%dT%H:%M:%S");
          console.log(format(start), format(end));

          urls.artItems = 'https://data.sfgov.org/resource/7rjr-9n9w.json';

          console.log(urls.artItems);

          const g = {
            edgeBunddling: svg.select("g#edgeBunddling"),
            basemap: svg.select("g#basemap"),
            streets: svg.select("g#streets"),
            outline: svg.select("g#outline"),
            artItems: svg.select("g#artItems"),
            tooltip: svg.select("g#tooltip"),
            details: svg.select("g#details")
          };


          const width = 960;
          const height = 500;
          const pad = 15;
          const r = 10;
          const diameter = 500;
          const color = d3.scaleSequential(d3.interpolateGnBu);
          //interpolateGnBu
          color.domain([0,235,471,706,942]);
          let matExactMap = {};
          let mTypeMap = {};
          let materialSet = new Set();
          let nodes = new Set();
          let original = [];
          let processed = [];
          let timeMap = {};
          let YIMTmap = {};
          let locMap = {};
          initializeYIMTmap();
          timeMap['architectural material'] = [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0];
          timeMap['metal'] = [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0];
          timeMap['mineral'] = [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0];
          timeMap['ecological'] = [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0];
          timeMap['daily life object']  = [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0];
          timeMap['kiln product'] = [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0];
          let rawDataPlatTableArr = [];
          let res = [];

          nodes.add('root');
          nodes.add('metal');
          nodes.add('mineral');
          nodes.add('ecological');
          nodes.add('daily life object');
          nodes.add('architectural material');
          nodes.add('kiln product');
          let typeName = ['architectural material', 'metal', 'mineral', 'ecological', 'daily life object', 'kiln product'];
          let yearInterval = ['1811-1835', '1836-1860', '1861-1885', '1886-1910', '1911-1935',
        '1936-1960', '1961-1985', '1986-2010', '2011-2035', 'unknown year'];
          //0: 1811-1835
          //1: 1836-1860
          //2: 1861-1885
          //3: 1886-1910
          //4: 1911-1935
          //5: 1936-1960
          //6: 1961-1985
          //7: 1986-2010
          //8: 2011-2035
          let yearIntervaoOptions = ['Select a year interval','all','1811-1835', '1836-1860', '1861-1885', '1886-1910', '1911-1935',
        '1936-1960', '1961-1985', '1986-2010', '2011-2035','unknown year'];
          var optionYI = d3.select("#YearIntercalSelectButton")
            .selectAll('myOptions')
            .data(yearIntervaoOptions)
            .enter()
            .append('option')
            .text(function (d) { return d; }) // text showed in the menu
            .attr("value", function (d) { return d; }) // corresponding value returned by the button

          let MaterialTypeOptions = ['Select a material type','all','architectural material', 'metal', 'mineral', 'ecological', 'daily life object', 'kiln product'];
          var optionMT = d3.select("#MaterialTypeSelectButton")
            .selectAll('myOptions')
            .data(MaterialTypeOptions)
            .enter()
            .append('option')
            .text(function (d) { return d; }) // text showed in the menu
            .attr("value", function (d) { return d; }) // corresponding value returned by the button
//'Select a year interval'  'Select a material type'
          let YearChosen = 'all';
          let MTypeChosen = 'all';
          let hmChosen = false;


          let metalSet = new Set(["bronze", "steel", "gold leaf", "brass", "aluminum", "zinc", "copper", "bronzing powder", "metalmaterial", "copper leaf", "iron", "gold"]);
          let mineralSet = new Set(["marble","granite", "terrazzo", "stone tiles", "cast stone", "soil", "lava rock", "stone", "basalt", "travertine", "graphite", "tesserae", "tuff stone", "stone boulder", "charcoal", "mortar",
          "crystals", "minerals", "red porphyry", "onyx"]);
          let ecoSet = new Set(["wood", "bone", "horn", "resin", "cotton", "plant", "oil", "wool", "planted earthwork", "wax", "bamboo", "ecological references", "water", "willow", "tule reed"]);

          let dailyLifeSet = new Set(["loudspeakers","images","ink", "cables", "mirror", "video", "magnets", "electrical reed switches"
          , "photogram", "wire", "egg tempera", "aero plate", "audiobox","electrical wiring",
          "pencil", "paper", "digital print", "buttons", "jewelry", "recycled parking meter heads", "brass saxophones", "steel music panels", "shade cloth", "controller", "motors","electronics","recycled mirrors", "annotated library cards"]);

          let architectureSet = new Set(["pigments","plastic mixture","paint", "mixed medium","plastic","led lighting","slate", "lighting", "asphalt","unknown", "mixed media relief","painted mural", "linoleum", "pigment", "architectural foam", "pigment print", "pastel", "archival pigment print", "cast aggregate", "mixed media color lino-cut print", "lacquer paint", "foam", "fabric collage", "soffits", "land scaping", "lino-cut print", "cement", "polyurethane foam",
          "found objects", "plaster", "fresco", "concrete", "mixed media", "neon lighting", "argon lighting", "fluorescent lighting", "lacquer paints", "mirror tile", "abaca paper", "ink with gesso", "led", "mural",
          "photography", "brick", "pipes", "polymer modified gypsum", "sisal rope"]);

          let kilnSet = new Set(["glaze","ceramic beads","porcelain enamel","porcelain", "ceramic tile", "clay", "glass", "cast glass", "frosted glass", "mosaic tile", "enamel", "ceramic", "gilding", "enamel paint", "terracotta tile", "glass tiles", "glazed ceramic"
          ,"crockery", "grout", "basaltic clay", "glass mosaic tile", "gfrc tile", "tile", "glass mosaic", "laminated digital print", "polyurethane paint"]);

          const csvMat = "artcommision_categorized_material - Civic_Art_Collection.csv";
          d3.csv(csvMat, recordMaterialInfo).then(makeHMDataFormat).then(drawAxis).then(drawHeatmap);
          d3.json(urls.basemap).then(function(json) {
            // makes sure to adjust projection to fit all of our regions
            projection.fitSize([960, 600], json);

            // draw the land and neighborhood outlines
            drawBasemap(json);

            // now that projection has been set trigger loading the other files
            // note that the actual order these files are loaded may differ
            d3.json(urls.streets).then(drawStreets);
            d3.json(urls.artItems).then(drawArtItems);
          });
        //.then(drawTitleCaptions);

          function recordMaterialInfo(row) {
            var materials = row.MediumMaterial;

            var matArr = materials.split(",");
            if(materials.length != 0) {
              index = 0;
              while (index < matArr.length) {
                temp = matArr[index];
                temp = temp.trim();
                temp = temp.toLowerCase();
                if(temp == "" || temp.length < 1) {
                  temp = "unknown";
                }
                materialSet.add(temp);

                artist = row.Artist;
                date = row.CreationFinishDate;
                acsNumber = row.AccessionNumber;
                mediumDetail = row.MediumDetail;
                displayTitle = row.DisplayTitle;
                latitude = row.Latitude;
                longitude = row.Longitude;
                nbh = row.SFFindNeighborhoods;
                locString = row.Latitude + "&" + row.Longitude;



                if(locMap[locString]) {
                  locAcsSet = locMap[locString];
                  locAcsSet.add(acsNumber);
                  locMap[locString] = locAcsSet;
  //            console.log(locAcsSet.size);
                } else { //ne wkey value locString
                  locAcsSet = new Set();
                  locAcsSet.add(acsNumber);
                  locMap[locString] = locAcsSet;
                }
            //    console.log('locMap: ');

      //          console.log(locMap);
// locMap[locString]    locString = row.Latitude + "&" + row.Longitude;   locAcsSet = locMap[locString]   locAcsSet.size



//locMap
                //metalSet, mineralSet, ecoSet, dailyLifeSet, architectureSet, kilnSet
                timeArrIndex = getTimeIntervalIndex(date);
                currYearInterval = yearInterval[timeArrIndex];


                if(metalSet.has(temp)) {
                  mType = "metal";
                } else if(mineralSet.has(temp)) {
                  mType = "mineral";
                } else if(ecoSet.has(temp)) {
                  mType = "ecological";
                } else if(dailyLifeSet.has(temp)) {
                  mType = "daily life object";
                } else if(architectureSet.has(temp)) {
                  mType = "architectural material";
                } else if(kilnSet.has(temp)) {
                  mType = "kiln product";
                } else {
                  console.log("not having: ");
                  console.log(temp);
                }

                if(temp == 'metal') {
                  console.log("@@@@@@@@@@@@@@@@@"+acsNumber);
                }

                setAllMT = YIMTmap['allYI']['all mType'];
                setAllMT.add(acsNumber);
                setAllYI = YIMTmap['allYI'][mType];
                setAllYI.add(acsNumber);
                setCurrYI = YIMTmap[currYearInterval][mType];
                setCurrYI.add(acsNumber);
                setCurrYIallMT = YIMTmap[currYearInterval]['all mType'];
                setCurrYIallMT.add(acsNumber);

                listTimeCount = timeMap[mType][timeArrIndex];
                listTimeCount ++;
                timeMap[mType][timeArrIndex] = listTimeCount;

                if(matExactMap[temp]) {

                  currMatList = matExactMap[temp];
                  currMatList.push({
                    'Material': temp,
                    'Artist': artist,
                    'Completion Year': date,
                    'Accession Number': acsNumber,
                    'MediumDetail': mediumDetail,
                    'DisplayTitle': displayTitle,
                    'Latitude': latitude,
                    'Longitude': longitude,
                    'Material Type': mType,
                    'Year Interval': currYearInterval
                  });
                  matExactMap[temp] = currMatList;
                } else {
                  currMatList = [];

                  currMatList.push({
                    'Material': temp,
                    'Artist': artist,
                    'Completion Year': date,
                    'Accession Number': acsNumber,
                    'MediumDetail': mediumDetail,
                    'DisplayTitle': displayTitle,
                    'Latitude': latitude,
                    'Longitude': longitude,
                    'Material Type': mType,
                    'Year Interval': currYearInterval
                  });
                  matExactMap[temp] = currMatList;
                }

                if(mTypeMap[mType]) {
                  typeSubMap = mTypeMap[mType];
                  if(typeSubMap[temp]) {
                    itemList = typeSubMap[temp];
                    itemList.push({
                      'Material': temp,
                      'Artist': artist,
                      'Completion Year': date,
                      'Accession Number': acsNumber,
                      'MediumDetail': mediumDetail,
                      'DisplayTitle': displayTitle,
                      'Latitude': latitude,
                      'Longitude': longitude,
                      'Material Type': mType,
                      'Year Interval': currYearInterval
                    })
                    typeSubMap[temp]= itemList;
                  } else {
                    itemList = [];
                    itemList.push({
                      'Material': temp,
                      'Artist': artist,
                      'Completion Year': date,
                      'Accession Number': acsNumber,
                      'MediumDetail': mediumDetail,
                      'DisplayTitle': displayTitle,
                      'Latitude': latitude,
                      'Longitude': longitude,
                      'Material Type': mType,
                      'Year Interval': currYearInterval
                    })
                    typeSubMap[temp]= itemList;

                  }
                  mTypeMap[mType] = typeSubMap;

                } else {
                  typeSubMap = {};

                  itemList = [];
                  itemList.push({
                    'Material': temp,
                    'Artist': artist,
                    'Completion Year': date,
                    'Accession Number': acsNumber,
                    'MediumDetail': mediumDetail,
                    'DisplayTitle': displayTitle,
                    'Latitude': latitude,
                    'Longitude': longitude,
                    'Material Type': mType,
                    'Year Interval': currYearInterval

                  })
                  typeSubMap[temp] = itemList;
                  mTypeMap[mType] = typeSubMap;
                }


                index++;
              }
            }
            rawDataPlatTableArr.push({
              'Artist': artist,
              'Completion Year': date,
              'Accession Number': acsNumber,
              'MediumDetail': mediumDetail,
              'DisplayTitle': displayTitle,
              'Latitude': latitude,
              'Longitude': longitude,
              'Material Type': mType,
              'Year Interval': currYearInterval
            })
            return materialSet;

          }

          function initializeYIMTmap() {
  //          ['1811-1835', '1836-1860', '1861-1885', '1886-1910', '1911-1935', '1936-1960', '1961-1985', '1986-2010', '2011-2035', 'unknown year']
            YIMTmap['allYI'] = initializeMTacsSubMap();
            YIMTmap['1811-1835'] = initializeMTacsSubMap();
            YIMTmap['1836-1860'] = initializeMTacsSubMap();
            YIMTmap['1861-1885'] = initializeMTacsSubMap();
            YIMTmap['1886-1910'] = initializeMTacsSubMap();
            YIMTmap['1911-1935'] = initializeMTacsSubMap();
            YIMTmap['1936-1960'] = initializeMTacsSubMap();
            YIMTmap['1961-1985'] = initializeMTacsSubMap();
            YIMTmap['1986-2010'] = initializeMTacsSubMap();
            YIMTmap['2011-2035'] = initializeMTacsSubMap();
            YIMTmap['unknown year'] = initializeMTacsSubMap();
            console.log("Completed YIMTmap: ");
            console.log(YIMTmap);
          }

          function initializeMTacsSubMap() {
            //typeName = ['architectural material', 'metal', 'mineral', 'ecological', 'daily life object', 'kiln product'];

            MTacsSubMap = {};
            MTacsSubMap['all mType'] = new Set();
            MTacsSubMap['architectural material'] = new Set();
            MTacsSubMap['metal'] = new Set();
            MTacsSubMap['mineral'] = new Set();
            MTacsSubMap['ecological'] = new Set();
            MTacsSubMap['daily life object'] = new Set();
            MTacsSubMap['kiln product'] = new Set();

            return MTacsSubMap;
          }


          function makeHMDataFormat(data) {

            console.log('timeMap: ');
            console.log(timeMap);
            console.log('rawDataPlatTableArr: ');
            console.log(rawDataPlatTableArr);
            console.log("Completed YIMTmap: ");
            console.log(YIMTmap);

            //prepare data format for heatmap
            i = 0;
            while(i < 6) {
              let oneRow = {};
              oneRow.values = [];
              count = 0;
              type = typeName[i];
              oneRow['type'] = type;

              while(count < 10) {
                oneRow.values.push({
                  'yearInterval': yearInterval[count],
                  'itemCount': timeMap[type][count],
                  'index': i
                })
                count ++;
              }

              res[i] = oneRow;
              i ++;
            }

            console.log(res);
            return res;
}


function makeCirTreeDataFormat(data) {
  console.log('matExactMap: ');
  console.log(matExactMap);
  console.log('materialSet: ');
  console.log(materialSet);
  console.log('mTypeMap: ');
  console.log(mTypeMap);

  console.log('rawDataPlatTableArr: ');
  console.log(rawDataPlatTableArr);


//metalSet, mineralSet, ecoSet, dailyLifeSet, architectureSet, kilnSet
  allCount = 0; //count of leaves

  archName = 'architectural material';
  typeCount = recordOneType(architectureSet, matExactMap, original, nodes, archName);
  allCount = allCount + typeCount;

  metalName = "metal";
  typeCount = recordOneType(metalSet, matExactMap, original, nodes, metalName);
  allCount = allCount + typeCount;

  mineralName = "mineral";
  typeCount = recordOneType(mineralSet, matExactMap, original, nodes, mineralName);
  allCount = allCount + typeCount;

  ecoName = "ecological";
  typeCount = recordOneType(ecoSet, matExactMap, original, nodes, ecoName);
  allCount = allCount + typeCount;

  dailyName = "daily life object";
  typeCount = recordOneType(dailyLifeSet, matExactMap, original, nodes, dailyName);
  allCount = allCount + typeCount;

  kilnName = "kiln product";
  typeCount = recordOneType(kilnSet, matExactMap, original, nodes, kilnName);
  allCount = allCount + typeCount;

  original.push({
    'name' : 'root',
    'parent' : '',
    'count' : allCount,
    'leave' : allCount
  })

  console.log('allCount: ' + allCount);
  console.log('original: ');
  console.log(original);


  root = d3.stratify()
.id(function(row) { return row.name; })
.parentId(function(row) {
return row.parent;
})
(original);

console.log("root: ");
console.log(root);


return root;
}


    function cirtree(data) {
          data.sort(function(a, b) {
            return b.height - a.height || b.count - a.count;
          });

          let layout = d3.tree().size([2 * Math.PI, (diameter / 2) - pad]);

          layout(data);

          data.each(function(node) {
            node.theta = node.x;
            node.radial = node.y;

            var point = toCartesian(node.radial, node.theta);
            node.x = point.x;
            node.y = point.y;
          });

          let plot = svg.append("g")
            .attr("id", "plot")
            .attr("transform", translate(pad + 90, pad));

            let line = d3.line()
              .curve(d3.curveLinear)
              .x(d => d.x + 900)
              .y(d => d.y + 260);

            let generator = function(node) {
              return line([node.source, node.target]);
            }

          drawLinks(plot.append("g"), data.links(), generator);
          drawNodes(plot.append("g"), data.descendants(), true);
          console.log(data.descendants());
          return svg.node();
        }

        function drawLinks(g, links, generator) {
          let paths = g.selectAll('path')
            .data(links)
            .enter()
            .append('path')
              .attr('d', generator)
              .attr('class', 'link')
              .style('stroke','silver')
              .style("fill-opacity", "0.8");
        }

        function drawNodes(g, nodes, raise) {
          let acsSet = new Set();
          if (YearChosen == 'all') {
            if(MTypeChosen == 'all') {
              acsSet = YIMTmap['allYI']['all mType'];
            } else {
              acsSet = YIMTmap['allYI'][MTypeChosen];
            }
          } else {
            if(MTypeChosen == 'all') {
              acsSet = YIMTmap[YearChosen]['all mType'];
            } else {
              acsSet = YIMTmap[YearChosen][MTypeChosen];
            }
          }

          console.log("acsSet before drawing nodes: ");
          console.log(acsSet);
          let circles = g.selectAll('circle')
            .data(nodes, node => node.data.name)
            .enter()
            .append('circle')
              .attr('r', r)
              .attr('cx', d => d.x + 900)
              .attr('cy', d => d.y + 260)
              .attr('id', d => d.data.name)
              .attr('class', 'node')
              .style('fill', d => color(d.data.count))
              .style('stroke','silver')
              .style("stroke-width", 1);

          setupEvents(g, circles, raise);
        }




        function toCartesian(r, theta) {
          return {
            x: r * Math.cos(theta),
            y: r * Math.sin(theta)
          };
        }


        function setupEvents(g, selection, raise) {

                 selection.on('mouseover.highlight', function(d) {
                   // https://github.com/d3/d3-hierarchy#node_path
                   // returns path from d3.select(this) node to selection.data()[0] root node
                   let path = d3.select(this).datum().path(selection.data()[0]);
            //       console.log(path);
                   // select all of the nodes on the shortest path
                   let update = selection.data(path, nodes => nodes.id);

                   // highlight the selected nodes
                   update.classed('selected', true);

                   if (raise) {
                     update.raise()
                     .style("stroke", "#e68a00")
                     .style("stroke-width", 5);
                   }
                 });

                 selection.on('mouseout.highlight', function(d) {
                   let path = d3.select(this).datum().path(selection.data()[0]);
                   let update = selection.data(path, node => node.data.name);
                   update.classed('selected', false);
                   update.style("stroke", "silver")
                   .style("stroke-width", 1);
                 });

                 // show tooltip text on mouseover (hover)
                 selection.on('mouseover.tooltip', function(d) {
                   showTooltip(g, d3.select(this));
                 });

                 // remove tooltip text on mouseout
                 selection.on('mouseout.tooltip', function(d) {
                   g.select("#tooltip").remove();
                 });
               }



               numberFormat = d3.format(".3~s");
               function showTooltip(g, node) {
                         let gbox = g.node().getBBox();     // get bounding box of group BEFORE adding text
                         let nbox = node.node().getBBox();  // get bounding box of node

                         // calculate shift amount
                         let dx = nbox.width / 2;
                         let dy = nbox.height / 2;

                         // retrieve node attributes (calculate middle point)
                         let x = nbox.x + dx;
                         let y = nbox.y + dy;

                         // get data for node
                         let datum = node.datum();


                         let name = datum.data.name;


                         let text = `${name}`;




                         // create tooltip
                         let tooltip = g.append('text')
                           .text(text)
                           .attr('x', x)
                           .attr('y', y)
                           .attr('dy', -dy - 4) // shift upward above circle
                           .attr('text-anchor', 'middle') // anchor in the middle
                           .attr('id', 'tooltip')
                           .style('stroke','orange');

                         // it is possible the tooltip will fall off the edge of the
                         // plot area. we can detect when this happens, and set the
                         // text anchor appropriately

                         // get bounding box for the text
                         let tbox = tooltip.node().getBBox();

                         // if text will fall off left side, anchor at start
                         if (tbox.x < gbox.x) {
                           tooltip.attr('text-anchor', 'start');
                           tooltip.attr('dx', -dx); // nudge text over from center
                         }
                         // if text will fall off right side, anchor at end
                         else if ((tbox.x + tbox.width) > (gbox.x + gbox.width)) {
                           tooltip.attr('text-anchor', 'end');
                           tooltip.attr('dx', dx);
                         }

                         // if text will fall off top side, place below circle instead
                         if (tbox.y < gbox.y) {
                           tooltip.attr('dy', dy + tbox.height);
                         }
                       }


function drawAxis(data) {

       console.log(data);

       // now that we have data set the scale domain
       scale.x.domain(yearInterval);
       scale.y.domain(typeName);

       // draw the x and y axis
       let gx = svg.append('g');
       gx.attr("id", "x-axis");
       gx.attr("class", "axis");
       plotX = config.plot.x;
       plotYH = config.plot.y + config.plot.height;

       gx.attr('transform', translate(plotX, plotYH));
       gx.call(axis.x);

       let gy = svg.append('g');
       gy.attr("id", "y-axis");
       gy.attr("class", "axis");

       plotY = config.plot.y;

       gy.attr('transform', translate(config.plot.x, config.plot.y));
       gy.call(axis.y);

       // add the options to the button

       return data;
     }


     function drawHeatmap(data) {
        //let typeName = ['architectural material', 'metal', 'mineral', 'ecological', 'daily life object', 'kiln product'];

        allValues = timeMap['architectural material'].concat(timeMap['metal'],
      timeMap['mineral'], timeMap['ecological'], timeMap['daily life object'], timeMap['kiln product'])

        allValues.sort((a,b)=>a-b);
        console.log(allValues);
        let min = d3.quantile(allValues, 0);
        let q1 = d3.quantile(allValues, 0.25);
        let median = d3.quantile(allValues, 0.5);
        let q3 = d3.quantile(allValues, 0.75);
        let max = d3.quantile(allValues, 1);

   //        scale.color.domain([min, q1, median, q3, max]);
   scale.color.domain([0, d3.max(allValues)]);

        // create one group per row
        let rows = plot.selectAll("g.cell")
               .data(data)
               .enter()
               .append("g");
             rows.attr("class", "cell");
             rows.attr("transform", function(d) {
               return translate(0, scale.y(d['type']));
             });

             let cells = rows.selectAll("rect")
               .data(d => d.values)
               .enter()
               .append("rect");

             cells.attr("x", d => scale.x(d.yearInterval));
             cells.attr("y", 0); // handled by group transform
             cells.attr("width", scale.x.bandwidth());
             cells.attr("height", scale.y.bandwidth());
             cells.style("stroke", "silver");
             cells.style("stroke-width", 0.5);

             // here is the color magic!
             cells.style("fill", d => scale.color(d.itemCount));

             cells.on("mouseover", function(d) {
                 let text = "How Many Times of Current Type of Material Used: " + d.itemCount;

                 // create tooltip
                 let tooltip = svg.append('text')
                    .text(text)
                    .attr('x', 360)
                    .attr('y', 795)
                    .attr('text-anchor', 'middle') // anchor in the middle
                    .attr('id', 'tooltip')
                    .attr("font-weight",300)
                    .style('fill', 'midnightblue');

                    cells.filter(e => (d.yearInterval !== e.yearInterval)).style("fill-opacity", "0.6");
                    cells.filter(e => (d.yearInterval !== e.yearInterval)).style("stroke", "#e5e5e5").style("fill-opacity", "0.6");
                    cells.filter(e => (d.index !== e.index)).style("fill-opacity", "0.6");
                    cells.filter(e => (d.index !== e.index)).style("stroke", "#e5e5e5").style("fill-opacity", "0.6");
                    cells.style("stroke", "silver");
             });

             cells.on("mouseout", function(d) {
                    d3.selectAll("#tooltip").remove();
                    cells.style("stroke", "silver");
                    cells.style("stroke-width", 0.5);
                    cells.style("fill", d => scale.color(d.itemCount)).style("fill-opacity", "1");
             });

             cells.on("click", function(d) {

                 YearChosen = d.yearInterval;
                 MTypeChosen = typeName[d.index];
                 optionYI.property("selected", function(d) {
                   if(YearChosen == 'unknown') {
                     YearChosen = 'unknown year';
                   }
                   return d === YearChosen;
                 });

                 optionMT.property("selected", function(d) {
                   return d === MTypeChosen;
                 });

                 console.log("hm: year: " + YearChosen);
                 console.log("hm: material type: " + MTypeChosen);

             });

           }


function restButtonClicker() {
  //'Select a year interval'  'Select a material type'
  optionYI.property("selected", function(d) {
    YearChosen = 'all';
    return d === 'Select a year interval';
  });

  optionMT.property("selected", function(d) {
    MTypeChosen = 'all';
    return d ==='Select a material type';
  });
}


function queryButtonClicked() {
    //YearIntercalSelectButton
    //MaterialTypeSelectButton
    requirement = [];

    console.log("query button clicked!!");

      d3.select("#YearIntercalSelectButton").on("change", function(d) {
        var selectedYear = d3.select(this).property("value");
        if(selectedYear == 'Select a year interval') {
          YearChosen = 'all';
        } else {
          YearChosen = selectedYear;
        }
        console.log("op CHANGED: year: " + YearChosen);

      })


      d3.select("#MaterialTypeSelectButton").on("change", function(d) {
        var selectedMType = d3.select(this).property("value");
        if(selectedMType == 'Select a material type') {
          MTypeChosen = 'all';
        } else {
          MTypeChosen = selectedMType;
        }
        console.log("op CHANGED: material type: " + MTypeChosen);

     })

console.log("op: year: " + YearChosen);
console.log("op: material type: " + MTypeChosen);
    requirement[0] = YearChosen;
    requirement[1] = MTypeChosen;
    d3.json(urls.artItems).then(drawArtItems);
    return requirement
}

function recordOneType(typeSet, matExactMap, original, nodes, typeName) {
  typeCount = 0;
  typeSetSize = typeSet.size;
  var typeItr = typeSet.entries();
  for(i=0;i<typeSetSize;i++){
    exactMaterial = typeItr.next().value[0];
    nodes.add(exactMaterial);

    exactList = [];
    exactList = matExactMap[exactMaterial];
//         console.log(exactMaterial);
        //  console.log(exactList);
    aitCount = exactList.length;

    original.push({
      'name' : exactMaterial,
      'parent' : typeName,
      'count' : aitCount,
      'leave' : 1
    })
    typeCount = typeCount + aitCount;
  }

  original.push({
    'name' : typeName,
    'parent' : 'root',
    'count' : typeCount,
    'leave' : typeCount
  })

  return typeCount;
}

function getTimeIntervalIndex(year) {
  //every 25 years
  //0: 1811-1835
  //1: 1836-1860
  //2: 1861-1885
  //3: 1886-1910
  //4: 1911-1935
  //5: 1936-1960
  //6: 1961-1985
  //7: 1986-2010
  //8: 2011-2035
  var yearValue = parseInt(year);

  var diff = yearValue - 1811;
  if(diff < 25) {
    return 0; //0: 1811-1835
  } else if(diff >= 25 && diff < 50){
    return 1; //1: 1836-1860
  } else if(diff >= 50 && diff < 75) {
    return 2; //2: 1861-1885
  } else if (diff >= 75 && diff < 100) {
    return 3; //3: 1886-1910
  } else if(diff >= 100 && diff < 125) {
    return 4;
  } else if(diff >= 125 && diff < 150) {
    return 5;
  } else if (diff >= 150 && diff < 175) {
    return 6;
  } else if (diff >= 175 && diff < 200) {
    return 7;
  } else if (diff >= 200 && diff < 225) {
    return 8;
  }

  return 9; //8 is for unkown year...

}


          function line() {
            d3.lineRadial()
              .curve(d3.curveBundle.beta(0.85))
              .radius(d => d.y)
              .angle(d => d.x)
          }

          function id(node) {
            return `${node.parent ? id(node.parent) + "." : ""}${node.data.name}`;
          }

          const tip = g.tooltip.append("text").attr("id", "tooltip");
          tip.attr("text-anchor", "end");
          tip.attr("dx", -5);
          tip.attr("dy", -5);
          tip.style("visibility", "hidden");

          // add details widget
          // https://bl.ocks.org/mbostock/1424037
          const details = g.details.append("foreignObject")
            .attr("id", "details")
            .attr("width", 700)
            .attr("height", 500)
            .attr("x", 700)
            .attr("y", 120);

          const body = details.append("xhtml:body")
            .style("text-align", "left")
            .style("background", "none")
            .html("<p>N/A</p>");

          details.style("visibility", "hidden");

          // setup projection
          // https://github.com/d3/d3-geo#geoConicEqualArea
          const projection = d3.geoConicEqualArea();
          projection.parallels([37.692514, 37.840699]);
          projection.rotate([122, 0]);

          // setup path generator (note it is a GEO path, not a normal path)
          const path = d3.geoPath().projection(projection);

          function drawBasemap(json) {
            console.log("basemap", json);

            const basemap = g.basemap.selectAll("path.land")
              .data(json.features)
              .enter()
              .append("path")
              .attr("d", path)
              .attr("class", "land");

            const outline = g.outline.selectAll("path.neighborhood")
                .data(json.features)
                .enter()
                .append("path")
                .attr("d", path)
                .attr("class", "neighborhood")
                .each(function(d) {
                  // save selection in data for interactivity
                  // saves search time finding the right outline later
                  d.properties.outline = this;
                });

            // add highlight
            basemap.on("mouseover.highlight", function(d) {
              d3.select(d.properties.outline).raise();
              d3.select(d.properties.outline).classed("active", true);
            })
            .on("mouseout.highlight", function(d) {
              d3.select(d.properties.outline).classed("active", false);
            });

            // add tooltip
      /*      basemap.on("mouseover.tooltip", function(d) {
              tip.text(d.properties.nhood);
              tip.style("visibility", "visible");
            })
            .on("mousemove.tooltip", function(d) {
              const coords = d3.mouse(g.basemap.node());
              tip.attr("x", coords[0]);
              tip.attr("y", coords[1]);
            })
            .on("mouseout.tooltip", function(d) {
              tip.style("visibility", "hidden");
            });
            */
          }

          function drawStreets(json) {
            console.log("streets", json);

            // only show active streets
            const streets = json.features.filter(function(d) {
              return d.properties.active;
            });

            console.log("removed", json.features.length - streets.length, "inactive streets");

            g.streets.selectAll("path.street")
              .data(streets)
              .enter()
              .append("path")
              .attr("d", path)
              .attr("class", "street");
          }

          function drawArtItems(json) {
            d3.selectAll("#allSymbols").remove();
            console.log('JSON for art items: ^^^^^^^^^^^^^^^^^^^');
            console.log(json);
            //if specific requirement, change set, otherwise use the default set...
            //according to queryReq, change the set range/content
            let acsSet = new Set();
            if (YearChosen == 'all') {
              if(MTypeChosen == 'all') {
                acsSet = YIMTmap['allYI']['all mType'];
              } else {
                acsSet = YIMTmap['allYI'][MTypeChosen];
              }
            } else {
              if(MTypeChosen == 'all') {
                acsSet = YIMTmap[YearChosen]['all mType'];
              } else {
                acsSet = YIMTmap[YearChosen][MTypeChosen];
              }
            }
            console.log("!!!!!!!!!!!!!!!!!!!!!!!current range: ");
            console.log(YearChosen + ", " + MTypeChosen +": ");
            console.log(acsSet);

            // loop through and add projected (x, y) coordinates
            // (just makes our d3 code a bit more simple later)
            count = 0;
            json.forEach(function(d) {
              if(!isNaN(d.latitude) && !isNaN(d.longitude)) {
                count++;
                const latitude = parseFloat(d.latitude);
                const longitude = parseFloat(d.longitude);
                const pixels = projection([longitude, latitude]);

                d.x = pixels[0];
                d.y = pixels[1];
              } else {
                d.x = -10;
                d.y = -10;
              }
            });

            // locMap[locString]    locString = row.Latitude + "&" + row.Longitude;   locAcsSet = locMap[locString]   locAcsSet.size

            const symbols = g.artItems.selectAll("circle")
              .data(json)
              .enter()
              .filter(d => (acsSet.has(d.accession_number)))
              .append("circle")
              .attr("id", "allSymbols")
              .attr("cx", function(d) { if(!isNaN(d.x))return d.x;})
              .attr("cy", function(d) { if(!isNaN(d.y))return d.y;})
              .attr("r", function(d) {
                locStr = d.latitude + "&" + d.longitude;

                if(locMap[locStr]) {
                  locSet = locMap[locStr];
                  //both in locSet and acsSet
                  var intersectionSet = locSet.intersection(acsSet);
                  caseCount = intersectionSet.size;

                  radius = (caseCount - 1) * 0.36 + 5;
                } else {
                  radius = 5;
                }
                return radius;
              })
              .attr("class", "symbol")
              .style("fill", "#e6b800");
      //      symbols.filter(d => (acsSet.has(d.AccessionNumber))).style("fill", "pink");
      //      console.log(d.AccessionNumber);



            symbolChosen = false;
            symbols.on("click", function(d) {
                symbols.style("fill", "#e6b800");

                if(symbolChosen == false) {
                  console.log('clicking symbol... ' + d.latitude + ", " + d.longitude);
                  len = rawDataPlatTableArr.length;
                  let chosenSymbolList = [];
                  for(i=0;i<len;i++) {
                    if(rawDataPlatTableArr[i]['Latitude'] == d.latitude
                    && rawDataPlatTableArr[i]['Longitude'] == d.longitude) {

                      console.log('clicking symbol... ' + rawDataPlatTableArr[i]['Latitude']
                      + ", " + rawDataPlatTableArr[i]['Longitude']);
                      chosenSymbolList.push({
                        'Display Title': rawDataPlatTableArr[i]['DisplayTitle'],
                        'Artist:': rawDataPlatTableArr[i]['Artist'],
                        'Completion Year': rawDataPlatTableArr[i]['Completion Year'],
                        'Accession Number': rawDataPlatTableArr[i]['Accession Number'],
                        'Medium Detail': rawDataPlatTableArr[i]['MediumDetail']
                      })
                    }

                  }
                  console.log('chosenSymbolList: ');
                  console.log(chosenSymbolList);
                  //TODO chosenSymbolList
                  //TODO to display!!
        /*          symbols.filter(e => (acsSet.has(e.AccessionNumber))).style("fill", "pink");
                  if(acsSet.has(d.AccessionNumber)) {
                    console.log("???");
                  }
*/


                  symbolChosen = true;
                } else {
                  symbols.style("fill", "#e6b800");
                  symbolChosen = false;
                }
            });

//TODO symbols clicked? show table of all art items in the "detail" table area?


            symbols.on("mouseover", function(d) {
              d3.select(this).raise();
              d3.select(this).classed("active", true);
              locStr = d.latitude + "&" + d.longitude;

              if(locMap[locStr]) {
                locSet = locMap[locStr]
                itemCount = locSet.size;

                locSet = locMap[locStr];
                //both in locSet and acsSet
                var intersectionSet = locSet.intersection(acsSet);
                caseCount = intersectionSet.size;
              } else {
                itemCount = 1;
              }

              // use template literal for the detail table
              // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Template_literals
              const html = `
                <table border="0" cellspacing="0" cellpadding="2">
                <tbody>
                <tr>
                  <th>Latitude, Longitude:</th>
                  <td>${d.latitude}, ${d.longitude}</td>
                </tr>

                <tr>
                  <th>Count of Art Item(s):</th>
                  <td>${caseCount}</td>
                </tr>


              </tbody>
              </table>`;

              body.html(html);
              details.style("visibility", "visible");
            });


            symbols.on("mouseout", function(d) {
              d3.select(this).classed("active", false);
              details.style("visibility", "hidden");
            });

          }

          function translate(x, y) {
            return "translate(" + String(x) + "," + String(y) + ")";
          }

          Set.prototype.intersection = function(otherSet){
              // creating new set to store intersection
              var intersectionSet = new Set();

              // Iterate over the values
              for(var elem of otherSet)
              {
                  // if the other set contains a
                  // similar value as of value[i]
                  // then add it to intersectionSet
                  if(this.has(elem))
                      intersectionSet.add(elem);
              }

          // return values of intersectionSet
          return intersectionSet;
          }

</script>


      </div>
      <!-- End page content -->
    </div>
  </section>

  <!-- Page footer -->
  <!-- https://bulma.io/documentation/layout/footer/ -->
  <footer class="footer">
    <div class="content has-text-centered is-size-7">
      <p>
        <a href="#top">
          <span class="fas fa-arrow-up"></span>
          <span class="has-text-weight-medium">Back to Top</span>
        </a>
      </p>

      <p>
        <a href="https://github.com/usf-cs360-spring2020/project-alexziweiwang" class="button is-small" style="padding-left: 1em; padding-right: 1em;" target = _blank>
          <i class="fab fa-github-alt"></i>&nbsp;<strong>Github</strong>
        </a>

        <a href="https://fontawesome.com/" class="button is-small" style="padding-left: 1em; padding-right: 1em;">
          <i class="fab fa-font-awesome"></i>&nbsp;<strong>FontAwesome</strong>
        </a>

        <a href="https://bulma.io" class="button is-small">
          <img src="https://bulma.io/images/made-with-bulma--semiblack.png" alt="Made with Bulma" width="128" height="24">
        </a>
      </p>
    </div>
  </footer>
  <!-- End page footer -->
  </body>

</html>
