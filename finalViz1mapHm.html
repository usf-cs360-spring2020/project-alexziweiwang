<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">

    <title>Final Visualization 1: Distribution Over Time - Materials Used on Art Items in San Francisco</title>

    <!-- Load Bulma from CDN (consider saving it to repository instead) -->
    <!-- https://bulma.io/ -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bulma@0.8.0/css/bulma.min.css">

    <!-- Load Font Awesome 5 (free) icons -->
    <script defer src="https://use.fontawesome.com/releases/v5.3.1/js/all.js"></script>


    <style>
    .hero-image {
      /* Use "linear-gradient" to add a darken background effect to the image (photographer.jpg). This will make the text easier to read */
      background-image: linear-gradient(rgba(0, 0, 0, 0.3), rgba(0, 0, 0, 0.3)), url("IMG_3853.JPG");

      /* Position and center the image to scale nicely on all screens */
      background-position: 30%;
      background-repeat: no-repeat;
      background-size: cover;
      position: relative;
    }

    .title {

    color: white;
    }

    .subtitle {
    color: white;
    }

  #ResetButton {
    font-size: 12px;
  }

  #YearIntercalSelectButton {
    font-size: 16px;
  }
  #MaterialTypeSelectButton {
    font-size: 16px;
  }
  #queryButton {
    font-size: 16px;
  }

  .axis {
    font: 16px sans-serif;
  }
  #tooltip {
    font-weight: 600;
    text-shadow: 0px 0px 2px white;

    fill: orange;
    stroke: black;
  }

  path.land {
    fill: #dddddd;
    stroke: none;
  }

  path.neighborhood {
    fill: none;
    stroke: white;
    stroke-width: 3.5px;
    pointer-events: none;
  }

  path.street {
    fill: none;
    stroke: white;
    stroke-width: 1px;
    pointer-events: none;
  }

  .active {
    stroke: orange !important;
    stroke-width: 1.5px !important;
  }

  circle.symbol {
    fill-opacity: 0.7;

    stroke: white;
    stroke-width: 1px;
  }

  th {
    text-align: right;
  }


 </style>
 <style>
 body {background-color:  #FEF8F4;
 }


 </style>
</head>

  <body>

  <!-- Page header -->
  <!-- https://bulma.io/documentation/layout/hero/ -->
  <section class="hero-image">
    <div class="hero-body">
      <div class="container">
        <h1 class="title">Final Visualization 1: Distribution Over Time - Materials Used on Art Items in San Francisco</h1>
        <h2 class="subtitle">Visualization in d3.js</h2>
      </div>
    </div>
  </section>
  <!-- End page header -->

  <!-- Page navigation -->
  <!-- https://bulma.io/documentation/components/navbar/ -->
  <nav class="navbar is-light" role="navigation" aria-label="main navigation">
    <div class="container">
      <div class="navbar-brand">
        <a class="navbar-item is-active" href="index.html">
          <span class="icon"><i class="fas fa-home"></i></span>
          <span>Home</span>
        </a>

        <a role="button" class="navbar-burger burger" aria-label="menu" aria-expanded="false" data-target="main-menu">
          <span aria-hidden="true"></span>
          <span aria-hidden="true"></span>
          <span aria-hidden="true"></span>
        </a>
      </div>

      <div id="main-menu" class="navbar-menu has-text-weight-medium">
        <!-- Left navbar items -->
        <div class="navbar-start">
          <a class="navbar-item" href="dts.html" title="Data">
            <span class="icon"><i class="fas fa-table"></i></span>
            <span>Data</span>
          </a>

          <div class="navbar-item has-dropdown is-hoverable">
            <a class="navbar-link">
              Visualizations
            </a>

            <div class="navbar-dropdown">
              <a class="navbar-item" href="pttpAlpha.html">
                <span class="icon"><i class="fas fa-chart-line"></i></span>
                <span>Prototype-Alpha: Art Items on Map of San Francisco - Non-proportional Symbol Map in Tableau (with feedback)</span>
              </a>

              <a class="navbar-item" href="pttpBeta2.html">
                <span class="icon"><i class="fas fa-chart-line"></i></span>
                <span>Prototype-Beta-OverallMap:  Clustering of Artists that Use Similar Materials? - non-proportional symbol map in d3.js (with feedback)</span>
              </a>

              <a class="navbar-item" href="finalViz1mapHm.html">
                <span class="icon"><i class="fas fa-chart-line"></i></span>
                <span>Final Visualization 1: Distribution Over Time - Materials Used on Art Items in San Francisco</span>
              </a>

              <a class="navbar-item" href="finalViz2Hierarchical.html">
                <span class="icon"><i class="fas fa-chart-line"></i></span>
                <span>Final Visualization 2: Hierarchical Relationship - Types of Materials Used on Art Items in San Francisco </span>
              </a>


            </div>
          </div>
        </div>

        <!-- Right navbar items -->
        <div class="navbar-end">
          <a class="navbar-item" href="abt.html" title="About">
            <span class="icon"><i class="fas fa-info-circle"></i></span>
            <span>About</span>
          </a>
        </div>
      </div>
    </div>
  </nav>
  <!-- End page navigation -->

  <section class="section">
    <div class="container">
      <!-- Begin page content -->
      <div class="content">

        <h1 class="title">
          Proportional Symbol Map & Heatmap
        </h1>

        <meta charset="utf-8">
        <figure>
          <svg width="1260" height="600" id="vis">
            <g id="basemap"></g>

            <!-- turn off pointer events for certain groups -->
            <g id="streets" pointer-events="none"></g>
            <g id="outline" pointer-events="none"></g>

            <g id="artItems"></g>
            <g id="tooltip" pointer-events="none"></g>
            <g id="details" pointer-events="none"></g>

          </svg>
          <p font-size = "30px">
              <button id="ResetButton" onclick="restButtonClicker()">reset</button>
              Filtering options:
              <select id="YearIntercalSelectButton"></select>
              <select id="MaterialTypeSelectButton"></select>
          <button id="queryButton" onclick="queryButtonClicked()">check art items on the map</button></br>
          <a href = "finalViz2Hierarchical.html" target = "_blank">What kind of materials are there in each type? (Click to see more specific material classifications!)</a>

        </p>

          <figcaption>
            Source: <a href="https://data.sfgov.org/Culture-and-Recreation/Civic-Art-Collection/7rjr-9n9w">Civic Art Collection</a>
            (<a href="https://data.sfgov.org/Geographic-Locations-and-Boundaries/Analysis-Neighborhoods/p5b7-5n3h">Neighborhoods</a>, <a href="https://data.sfgov.org/Geographic-Locations-and-Boundaries/Streets-Active-and-Retired/3psu-pn9h">Streets</a>)
          </figcaption>
        </figure>

        <script src="https://d3js.org/d3.v5.min.js"></script>

<script>

// configuration of svg/plot area
let config = {
  'svg': {},
  'margin': {},
  'plot': {}
};

config.svg.height = 800;
config.svg.width = 1440; // golden ratio

config.margin.top = 10;
config.margin.right = 220;
config.margin.bottom = -50;
config.margin.left = 160;

config.plot.x = config.margin.left;
config.plot.y = config.margin.top + 630;
config.plot.width = config.svg.width - config.margin.left - config.margin.right;
config.plot.height = config.svg.height - config.margin.top - config.margin.bottom - 720;

// setup svg
let svg = d3.select("body").select("svg#vis");
svg.attr('width', config.svg.width);
svg.attr('height', config.svg.height);

// setup plot area
let plot = svg.append('g');
plot.attr('id', 'plot');
plot.attr('transform', translate(config.plot.x, config.plot.y));

// use a rect to illustrate plot area
let rect = plot.append('rect');
rect.attr('id', 'background');

rect.attr('x', 0);
rect.attr('y', 0);
rect.attr('width', config.plot.width);
rect.attr('height', config.plot.height);

// scales for data
let scale = {
  r: d3.scaleSqrt()
};

scale.x = d3.scaleBand();
scale.x.range([0, config.plot.width]);

scale.y = d3.scaleBand();
scale.y.range([config.plot.height, 0]);

// https://github.com/d3/d3-scale-chromatic
scale.color = d3.scaleSequential(d3.interpolatePurples);
scale.r.range([1, 20]).domain([0, 90]);



//interpolatePuBuGn


let axis = {};  // axes for data
axis.x = d3.axisBottom(scale.x);
axis.x.tickPadding(0);

axis.y = d3.axisLeft(scale.y);
axis.y.tickPadding(0);


          const urls = {
            basemap: "https://data.sfgov.org/resource/xfcw-9evu.geojson",
            streets: "https://data.sfgov.org/resource/3psu-pn9h.geojson?$limit=8000",
            artItems: "https://data.sfgov.org/resource/7rjr-9n9w.json"
          };

          // calculate date range
          const end = d3.timeDay.floor(d3.timeDay.offset(new Date(), -1));
          const start = d3.timeDay.floor(d3.timeDay.offset(end, -7));
          const format = d3.timeFormat("%Y-%m-%dT%H:%M:%S");
          console.log(format(start), format(end));

          urls.artItems = 'https://data.sfgov.org/resource/7rjr-9n9w.json';

          console.log(urls.artItems);

          const g = {
            edgeBunddling: svg.select("g#edgeBunddling"),
            basemap: svg.select("g#basemap"),
            streets: svg.select("g#streets"),
            outline: svg.select("g#outline"),
            artItems: svg.select("g#artItems"),
            tooltip: svg.select("g#tooltip"),
            details: svg.select("g#details")
          };


          const width = 960;
          const height = 500;
          const pad = 15;
          const r = 10;
          const diameter = 500;
          const color = d3.scaleSequential(d3.interpolateGnBu);
          //interpolateGnBu
          color.domain([0,235,471,706,942]);
          let matExactMap = {};
          let mTypeMap = {};
          let materialSet = new Set();
          let nodes = new Set();
          let original = [];
          let processed = [];
          let timeMap = {};
          let YIMTmap = {};
          let locMap = {};
          let jsonInputArray = [];
          initializeYIMTmap();
          timeMap['architectural material'] = [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0];
          timeMap['metal'] = [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0];
          timeMap['mineral'] = [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0];
          timeMap['ecological'] = [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0];
          timeMap['daily life object']  = [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0];
          timeMap['kiln product'] = [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0];
          let rawDataPlatTableArr = [];
          let res = [];

          nodes.add('root');
          nodes.add('metal');
          nodes.add('mineral');
          nodes.add('ecological');
          nodes.add('daily life object');
          nodes.add('architectural material');
          nodes.add('kiln product');
          let typeName = ['architectural material', 'metal', 'mineral', 'ecological', 'daily life object', 'kiln product'];
          let yearInterval = ['1811-1835', '1836-1860', '1861-1885', '1886-1910', '1911-1935',
        '1936-1960', '1961-1985', '1986-2010', '2011-2035', 'unknown year'];
          //0: 1811-1835
          //1: 1836-1860
          //2: 1861-1885
          //3: 1886-1910
          //4: 1911-1935
          //5: 1936-1960
          //6: 1961-1985
          //7: 1986-2010
          //8: 2011-2035
          let yearIntervaoOptions = ['Select a year interval','all','1811-1835', '1836-1860', '1861-1885', '1886-1910', '1911-1935',
        '1936-1960', '1961-1985', '1986-2010', '2011-2035','unknown year'];
          var optionYI = d3.select("#YearIntercalSelectButton")
            .selectAll('myOptions')
            .data(yearIntervaoOptions)
            .enter()
            .append('option')
            .text(function (d) { return d; }) // text showed in the menu
            .attr("value", function (d) { return d; }) // corresponding value returned by the button

          let MaterialTypeOptions = ['Select a material type','all','architectural material', 'metal', 'mineral', 'ecological', 'daily life object', 'kiln product'];
          var optionMT = d3.select("#MaterialTypeSelectButton")
            .selectAll('myOptions')
            .data(MaterialTypeOptions)
            .enter()
            .append('option')
            .text(function (d) { return d; }) // text showed in the menu
            .attr("value", function (d) { return d; }) // corresponding value returned by the button
//'Select a year interval'  'Select a material type'
          let YearChosen = 'all';
          let MTypeChosen = 'all';
          let hmChosen = false;


          let metalSet = new Set(["bronze", "steel", "gold leaf", "brass", "aluminum", "zinc", "copper", "bronzing powder", "metalmaterial", "copper leaf", "iron", "gold"]);
          let mineralSet = new Set(["marble","granite", "terrazzo", "stone tiles", "cast stone", "soil", "lava rock", "stone", "basalt", "travertine", "graphite", "tesserae", "tuff stone", "stone boulder", "charcoal", "mortar",
          "crystals", "minerals", "red porphyry", "onyx"]);
          let ecoSet = new Set(["wood", "bone", "horn", "resin", "cotton", "plant", "oil", "wool", "planted earthwork", "wax", "bamboo", "ecological references", "water", "willow", "tule reed"]);

          let dailyLifeSet = new Set(["loudspeakers","images","ink", "cables", "mirror", "video", "magnets", "electrical reed switches"
          , "photogram", "wire", "egg tempera", "aero plate", "audiobox","electrical wiring",
          "pencil", "paper", "digital print", "buttons", "jewelry", "recycled parking meter heads", "brass saxophones", "steel music panels", "shade cloth", "controller", "motors","electronics","recycled mirrors", "annotated library cards"]);

          let architectureSet = new Set(["pigments","plastic mixture","paint", "mixed medium","plastic","led lighting","slate", "lighting", "asphalt","unknown", "mixed media relief","painted mural", "linoleum", "pigment", "architectural foam", "pigment print", "pastel", "archival pigment print", "cast aggregate", "mixed media color lino-cut print", "lacquer paint", "foam", "fabric collage", "soffits", "land scaping", "lino-cut print", "cement", "polyurethane foam",
          "found objects", "plaster", "fresco", "concrete", "mixed media", "neon lighting", "argon lighting", "fluorescent lighting", "lacquer paints", "mirror tile", "abaca paper", "ink with gesso", "led", "mural",
          "photography", "brick", "pipes", "polymer modified gypsum", "sisal rope"]);

          let kilnSet = new Set(["glaze","ceramic beads","porcelain enamel","porcelain", "ceramic tile", "clay", "glass", "cast glass", "frosted glass", "mosaic tile", "enamel", "ceramic", "gilding", "enamel paint", "terracotta tile", "glass tiles", "glazed ceramic"
          ,"crockery", "grout", "basaltic clay", "glass mosaic tile", "gfrc tile", "tile", "glass mosaic", "laminated digital print", "polyurethane paint"]);

          const csvMat = "artcommision_categorized_material - Civic_Art_Collection.csv";
          d3.csv(csvMat, recordMaterialInfo).then(makeHMDataFormat).then(drawAxis).then(drawHeatmap).then(drawColorLegend).then(drawCircleLegend);
          d3.json(urls.basemap).then(function(json) {
            // makes sure to adjust projection to fit all of our regions
            projection.fitSize([960, 600], json);

            // draw the land and neighborhood outlines
            drawBasemap(json);

            // now that projection has been set trigger loading the other files
            // note that the actual order these files are loaded may differ
            d3.json(urls.streets).then(drawStreets);
            d3.json(urls.artItems).then(drawArtItems);
          });
        //.then(drawTitleCaptions);

          function recordMaterialInfo(row) {
            var materials = row.MediumMaterial;

            var matArr = materials.split(",");
            if(materials.length != 0) {
              index = 0;
              while (index < matArr.length) {
                temp = matArr[index];
                temp = temp.trim();
                temp = temp.toLowerCase();
                if(temp == "" || temp.length < 1) {
                  temp = "unknown";
                }
                materialSet.add(temp);

                artist = row.Artist;
                date = row.CreationFinishDate;
                acsNumber = row.AccessionNumber;
                mediumDetail = row.MediumDetail;
                displayTitle = row.DisplayTitle;
                latitude = row.Latitude;
                longitude = row.Longitude;
                nbh = row.SFFindNeighborhoods;
                locString = row.Latitude + "&" + row.Longitude;



                if(locMap[locString]) {
                  locAcsSet = locMap[locString];
                  locAcsSet.add(acsNumber);
                  locMap[locString] = locAcsSet;
  //            console.log(locAcsSet.size);
                } else { //ne wkey value locString
                  locAcsSet = new Set();
                  locAcsSet.add(acsNumber);
                  locMap[locString] = locAcsSet;
                }
            //    console.log('locMap: ');

      //          console.log(locMap);
// locMap[locString]    locString = row.Latitude + "&" + row.Longitude;   locAcsSet = locMap[locString]   locAcsSet.size



//locMap
                //metalSet, mineralSet, ecoSet, dailyLifeSet, architectureSet, kilnSet
                timeArrIndex = getTimeIntervalIndex(date);
                currYearInterval = yearInterval[timeArrIndex];


                if(metalSet.has(temp)) {
                  mType = "metal";
                } else if(mineralSet.has(temp)) {
                  mType = "mineral";
                } else if(ecoSet.has(temp)) {
                  mType = "ecological";
                } else if(dailyLifeSet.has(temp)) {
                  mType = "daily life object";
                } else if(architectureSet.has(temp)) {
                  mType = "architectural material";
                } else if(kilnSet.has(temp)) {
                  mType = "kiln product";
                } else {
                  console.log("not having: ");
                  console.log(temp);
                }

                if(temp == 'metal') {
                  console.log("@@@@@@@@@@@@@@@@@"+acsNumber);
                }

                setAllMT = YIMTmap['allYI']['all mType'];
                setAllMT.add(acsNumber);
                setAllYI = YIMTmap['allYI'][mType];
                setAllYI.add(acsNumber);
                setCurrYI = YIMTmap[currYearInterval][mType];
                setCurrYI.add(acsNumber);
                setCurrYIallMT = YIMTmap[currYearInterval]['all mType'];
                setCurrYIallMT.add(acsNumber);

                listTimeCount = timeMap[mType][timeArrIndex];
                listTimeCount ++;
                timeMap[mType][timeArrIndex] = listTimeCount;

                if(matExactMap[temp]) {

                  currMatList = matExactMap[temp];
                  currMatList.push({
                    'Material': temp,
                    'Artist': artist,
                    'Completion Year': date,
                    'Accession Number': acsNumber,
                    'MediumDetail': mediumDetail,
                    'DisplayTitle': displayTitle,
                    'Latitude': latitude,
                    'Longitude': longitude,
                    'Material Type': mType,
                    'Year Interval': currYearInterval
                  });
                  matExactMap[temp] = currMatList;
                } else {
                  currMatList = [];

                  currMatList.push({
                    'Material': temp,
                    'Artist': artist,
                    'Completion Year': date,
                    'Accession Number': acsNumber,
                    'MediumDetail': mediumDetail,
                    'DisplayTitle': displayTitle,
                    'Latitude': latitude,
                    'Longitude': longitude,
                    'Material Type': mType,
                    'Year Interval': currYearInterval
                  });
                  matExactMap[temp] = currMatList;
                }

                if(mTypeMap[mType]) {
                  typeSubMap = mTypeMap[mType];
                  if(typeSubMap[temp]) {
                    itemList = typeSubMap[temp];
                    itemList.push({
                      'Material': temp,
                      'Artist': artist,
                      'Completion Year': date,
                      'Accession Number': acsNumber,
                      'MediumDetail': mediumDetail,
                      'DisplayTitle': displayTitle,
                      'Latitude': latitude,
                      'Longitude': longitude,
                      'Material Type': mType,
                      'Year Interval': currYearInterval
                    })
                    typeSubMap[temp]= itemList;
                  } else {
                    itemList = [];
                    itemList.push({
                      'Material': temp,
                      'Artist': artist,
                      'Completion Year': date,
                      'Accession Number': acsNumber,
                      'MediumDetail': mediumDetail,
                      'DisplayTitle': displayTitle,
                      'Latitude': latitude,
                      'Longitude': longitude,
                      'Material Type': mType,
                      'Year Interval': currYearInterval
                    })
                    typeSubMap[temp]= itemList;

                  }
                  mTypeMap[mType] = typeSubMap;

                } else {
                  typeSubMap = {};

                  itemList = [];
                  itemList.push({
                    'Material': temp,
                    'Artist': artist,
                    'Completion Year': date,
                    'Accession Number': acsNumber,
                    'MediumDetail': mediumDetail,
                    'DisplayTitle': displayTitle,
                    'Latitude': latitude,
                    'Longitude': longitude,
                    'Material Type': mType,
                    'Year Interval': currYearInterval

                  })
                  typeSubMap[temp] = itemList;
                  mTypeMap[mType] = typeSubMap;
                }


                index++;
              }
            }
            rawDataPlatTableArr.push({
              'Artist': artist,
              'Completion Year': date,
              'Accession Number': acsNumber,
              'MediumDetail': mediumDetail,
              'DisplayTitle': displayTitle,
              'Latitude': latitude,
              'Longitude': longitude,
              'Material Type': mType,
              'Year Interval': currYearInterval
            })
            return materialSet;

          }

          function initializeYIMTmap() {
  //          ['1811-1835', '1836-1860', '1861-1885', '1886-1910', '1911-1935', '1936-1960', '1961-1985', '1986-2010', '2011-2035', 'unknown year']
            YIMTmap['allYI'] = initializeMTacsSubMap();
            YIMTmap['1811-1835'] = initializeMTacsSubMap();
            YIMTmap['1836-1860'] = initializeMTacsSubMap();
            YIMTmap['1861-1885'] = initializeMTacsSubMap();
            YIMTmap['1886-1910'] = initializeMTacsSubMap();
            YIMTmap['1911-1935'] = initializeMTacsSubMap();
            YIMTmap['1936-1960'] = initializeMTacsSubMap();
            YIMTmap['1961-1985'] = initializeMTacsSubMap();
            YIMTmap['1986-2010'] = initializeMTacsSubMap();
            YIMTmap['2011-2035'] = initializeMTacsSubMap();
            YIMTmap['unknown year'] = initializeMTacsSubMap();
            console.log("Completed YIMTmap: ");
            console.log(YIMTmap);
          }

          function initializeMTacsSubMap() {
            //typeName = ['architectural material', 'metal', 'mineral', 'ecological', 'daily life object', 'kiln product'];

            MTacsSubMap = {};
            MTacsSubMap['all mType'] = new Set();
            MTacsSubMap['architectural material'] = new Set();
            MTacsSubMap['metal'] = new Set();
            MTacsSubMap['mineral'] = new Set();
            MTacsSubMap['ecological'] = new Set();
            MTacsSubMap['daily life object'] = new Set();
            MTacsSubMap['kiln product'] = new Set();

            return MTacsSubMap;
          }


          function makeHMDataFormat(data) {

            console.log('timeMap: ');
            console.log(timeMap);
            console.log('rawDataPlatTableArr: ');
            console.log(rawDataPlatTableArr);
            console.log("Completed YIMTmap: ");
            console.log(YIMTmap);

            //prepare data format for heatmap
            i = 0;
            while(i < 6) {
              let oneRow = {};
              oneRow.values = [];
              count = 0;
              type = typeName[i];
              oneRow['type'] = type;

              while(count < 10) {
                oneRow.values.push({
                  'yearInterval': yearInterval[count],
                  'itemCount': timeMap[type][count],
                  'index': i
                })
                count ++;
              }

              res[i] = oneRow;
              i ++;
            }

            console.log(res);
            return res;
}


function makeCirTreeDataFormat(data) {
  console.log('matExactMap: ');
  console.log(matExactMap);
  console.log('materialSet: ');
  console.log(materialSet);
  console.log('mTypeMap: ');
  console.log(mTypeMap);

  console.log('rawDataPlatTableArr: ');
  console.log(rawDataPlatTableArr);


//metalSet, mineralSet, ecoSet, dailyLifeSet, architectureSet, kilnSet
  allCount = 0; //count of leaves

  archName = 'architectural material';
  typeCount = recordOneType(architectureSet, matExactMap, original, nodes, archName);
  allCount = allCount + typeCount;

  metalName = "metal";
  typeCount = recordOneType(metalSet, matExactMap, original, nodes, metalName);
  allCount = allCount + typeCount;

  mineralName = "mineral";
  typeCount = recordOneType(mineralSet, matExactMap, original, nodes, mineralName);
  allCount = allCount + typeCount;

  ecoName = "ecological";
  typeCount = recordOneType(ecoSet, matExactMap, original, nodes, ecoName);
  allCount = allCount + typeCount;

  dailyName = "daily life object";
  typeCount = recordOneType(dailyLifeSet, matExactMap, original, nodes, dailyName);
  allCount = allCount + typeCount;

  kilnName = "kiln product";
  typeCount = recordOneType(kilnSet, matExactMap, original, nodes, kilnName);
  allCount = allCount + typeCount;

  original.push({
    'name' : 'root',
    'parent' : '',
    'count' : allCount,
    'leave' : allCount
  })

  console.log('allCount: ' + allCount);
  console.log('original: ');
  console.log(original);


  root = d3.stratify()
.id(function(row) { return row.name; })
.parentId(function(row) {
return row.parent;
})
(original);

console.log("root: ");
console.log(root);


return root;
}


    function cirtree(data) {
          data.sort(function(a, b) {
            return b.height - a.height || b.count - a.count;
          });

          let layout = d3.tree().size([2 * Math.PI, (diameter / 2) - pad]);

          layout(data);

          data.each(function(node) {
            node.theta = node.x;
            node.radial = node.y;

            var point = toCartesian(node.radial, node.theta);
            node.x = point.x;
            node.y = point.y;
          });

          let plot = svg.append("g")
            .attr("id", "plot")
            .attr("transform", translate(pad + 90, pad));

            let line = d3.line()
              .curve(d3.curveLinear)
              .x(d => d.x + 900)
              .y(d => d.y + 260);

            let generator = function(node) {
              return line([node.source, node.target]);
            }

          drawLinks(plot.append("g"), data.links(), generator);
          drawNodes(plot.append("g"), data.descendants(), true);
          console.log(data.descendants());
          return svg.node();
        }

        function drawLinks(g, links, generator) {
          let paths = g.selectAll('path')
            .data(links)
            .enter()
            .append('path')
              .attr('d', generator)
              .attr('class', 'link')
              .style('stroke','silver')
              .style("fill-opacity", "0.8");
        }

        function drawNodes(g, nodes, raise) {
          let acsSet = new Set();
          if (YearChosen == 'all') {
            if(MTypeChosen == 'all') {
              acsSet = YIMTmap['allYI']['all mType'];
            } else {
              acsSet = YIMTmap['allYI'][MTypeChosen];
            }
          } else {
            if(MTypeChosen == 'all') {
              acsSet = YIMTmap[YearChosen]['all mType'];
            } else {
              acsSet = YIMTmap[YearChosen][MTypeChosen];
            }
          }

          console.log("acsSet before drawing nodes: ");
          console.log(acsSet);
          let circles = g.selectAll('circle')
            .data(nodes, node => node.data.name)
            .enter()
            .append('circle')
              .attr('r', r)
              .attr('cx', d => d.x + 900)
              .attr('cy', d => d.y + 260)
              .attr('id', d => d.data.name)
              .attr('class', 'node')
              .style('fill', d => color(d.data.count))
              .style('stroke','silver')
              .style("stroke-width", 1);

          setupEvents(g, circles, raise);
        }




        function toCartesian(r, theta) {
          return {
            x: r * Math.cos(theta),
            y: r * Math.sin(theta)
          };
        }


        function setupEvents(g, selection, raise) {

                 selection.on('mouseover.highlight', function(d) {
                   // https://github.com/d3/d3-hierarchy#node_path
                   // returns path from d3.select(this) node to selection.data()[0] root node
                   let path = d3.select(this).datum().path(selection.data()[0]);
            //       console.log(path);
                   // select all of the nodes on the shortest path
                   let update = selection.data(path, nodes => nodes.id);

                   // highlight the selected nodes
                   update.classed('selected', true);

                   if (raise) {
                     update.raise()
                     .style("stroke", "#e68a00")
                     .style("stroke-width", 5);
                   }
                 });

                 selection.on('mouseout.highlight', function(d) {
                   let path = d3.select(this).datum().path(selection.data()[0]);
                   let update = selection.data(path, node => node.data.name);
                   update.classed('selected', false);
                   update.style("stroke", "silver")
                   .style("stroke-width", 1);
                 });

                 // show tooltip text on mouseover (hover)
                 selection.on('mouseover.tooltip', function(d) {
                   showTooltip(g, d3.select(this));
                 });

                 // remove tooltip text on mouseout
                 selection.on('mouseout.tooltip', function(d) {
                   g.select("#tooltip").remove();
                 });
               }



               numberFormat = d3.format(".3~s");
               function showTooltip(g, node) {
                         let gbox = g.node().getBBox();     // get bounding box of group BEFORE adding text
                         let nbox = node.node().getBBox();  // get bounding box of node

                         // calculate shift amount
                         let dx = nbox.width / 2;
                         let dy = nbox.height / 2;

                         // retrieve node attributes (calculate middle point)
                         let x = nbox.x + dx;
                         let y = nbox.y + dy;

                         // get data for node
                         let datum = node.datum();


                         let name = datum.data.name;


                         let text = `${name}`;




                         // create tooltip
                         let tooltip = g.append('text')
                           .text(text)
                           .attr('x', x)
                           .attr('y', y)
                           .attr('dy', -dy - 4) // shift upward above circle
                           .attr('text-anchor', 'middle') // anchor in the middle
                           .attr('id', 'tooltip')
                           .style('stroke','orange');

                         // it is possible the tooltip will fall off the edge of the
                         // plot area. we can detect when this happens, and set the
                         // text anchor appropriately

                         // get bounding box for the text
                         let tbox = tooltip.node().getBBox();

                         // if text will fall off left side, anchor at start
                         if (tbox.x < gbox.x) {
                           tooltip.attr('text-anchor', 'start');
                           tooltip.attr('dx', -dx); // nudge text over from center
                         }
                         // if text will fall off right side, anchor at end
                         else if ((tbox.x + tbox.width) > (gbox.x + gbox.width)) {
                           tooltip.attr('text-anchor', 'end');
                           tooltip.attr('dx', dx);
                         }

                         // if text will fall off top side, place below circle instead
                         if (tbox.y < gbox.y) {
                           tooltip.attr('dy', dy + tbox.height);
                         }
                       }


function drawAxis(data) {

       console.log(data);

       // now that we have data set the scale domain
       scale.x.domain(yearInterval);
       scale.y.domain(typeName);

       // draw the x and y axis
       let gx = svg.append('g');
       gx.attr("id", "x-axis");
       gx.attr("class", "axis");
       plotX = config.plot.x;
       plotYH = config.plot.y + config.plot.height;

       gx.attr('transform', translate(plotX, plotYH));
       gx.call(axis.x);

       let gy = svg.append('g');
       gy.attr("id", "y-axis");
       gy.attr("class", "axis");

       plotY = config.plot.y;

       gy.attr('transform', translate(config.plot.x, config.plot.y));
       gy.call(axis.y);

       // add the options to the button

       return data;
     }


     function drawHeatmap(data) {
       const graphTitle = g.artItems.append('text')
         .text('Distribution Over Time of Materials Used on Art Items in San Francisco');
         graphTitle.attr("id", 'graphTitle');
         graphTitle.attr('dx', 20);
         graphTitle.attr('dy', 75);
         graphTitle.attr('font-size', '23px');
        //let typeName = ['architectural material', 'metal', 'mineral', 'ecological', 'daily life object', 'kiln product'];

        allValues = timeMap['architectural material'].concat(timeMap['metal'],
      timeMap['mineral'], timeMap['ecological'], timeMap['daily life object'], timeMap['kiln product'])

        allValues.sort((a,b)=>a-b);
        console.log(allValues);
        let min = d3.quantile(allValues, 0);
        let q1 = d3.quantile(allValues, 0.25);
        let median = d3.quantile(allValues, 0.5);
        let q3 = d3.quantile(allValues, 0.75);
        let max = d3.quantile(allValues, 1);

   //        scale.color.domain([min, q1, median, q3, max]);
   scale.color.domain([0, d3.max(allValues)]);

        // create one group per row
        let rows = plot.selectAll("g.cell")
               .data(data)
               .enter()
               .append("g");
             rows.attr("class", "cell");
             rows.attr("transform", function(d) {
               return translate(0, scale.y(d['type']));
             });

             let cells = rows.selectAll("rect")
               .data(d => d.values)
               .enter()
               .append("rect");

             cells.attr("x", d => scale.x(d.yearInterval));
             cells.attr("y", 0); // handled by group transform
             cells.attr("width", scale.x.bandwidth());
             cells.attr("height", scale.y.bandwidth());
             cells.style("stroke", "silver");
             cells.style("stroke-width", 0.5);

             // here is the color magic!
             cells.style("fill", d => scale.color(d.itemCount));

             cells.on("mouseover", function(d) {
                 let text = "How Many Times of Current Type of Material Used: " + d.itemCount;

                 // create tooltip
                 let tooltip = svg.append('text')
                    .text(text)
                    .attr('x', 360)
                    .attr('y', 795)
                    .attr('text-anchor', 'middle') // anchor in the middle
                    .attr('id', 'tooltip')
                    .attr("font-weight",300)
                    .style('fill', 'midnightblue');

                    cells.filter(e => (d.yearInterval !== e.yearInterval)).style("fill-opacity", "0.6");
                    cells.filter(e => (d.yearInterval !== e.yearInterval)).style("stroke", "#e5e5e5").style("fill-opacity", "0.6");
                    cells.filter(e => (d.index !== e.index)).style("fill-opacity", "0.6");
                    cells.filter(e => (d.index !== e.index)).style("stroke", "#e5e5e5").style("fill-opacity", "0.6");
                    cells.style("stroke", "silver");
             });

             cells.on("mouseout", function(d) {
                    d3.selectAll("#tooltip").remove();
                    cells.style("stroke", "silver");
                    cells.style("stroke-width", 0.5);
                    cells.style("fill", d => scale.color(d.itemCount)).style("fill-opacity", "1");
             });

             cells.on("click", function(d) {

                 YearChosen = d.yearInterval;
                 MTypeChosen = typeName[d.index];
                 optionYI.property("selected", function(d) {
                   if(YearChosen == 'unknown') {
                     YearChosen = 'unknown year';
                   }
                   return d === YearChosen;
                 });

                 optionMT.property("selected", function(d) {
                   return d === MTypeChosen;
                 });

                 console.log("hm: year: " + YearChosen);
                 console.log("hm: material type: " + MTypeChosen);

             });

           }


function restButtonClicker() {
  //'Select a year interval'  'Select a material type'
  optionYI.property("selected", function(d) {
    YearChosen = 'all';
    return d === 'Select a year interval';
  });

  optionMT.property("selected", function(d) {
    MTypeChosen = 'all';
    return d ==='Select a material type';
  });
}


function queryButtonClicked() {
    //YearIntercalSelectButton
    //MaterialTypeSelectButton
    requirement = [];

    console.log("query button clicked!!");

      d3.select("#YearIntercalSelectButton").on("change", function(d) {
        var selectedYear = d3.select(this).property("value");
        if(selectedYear == 'Select a year interval') {
          YearChosen = 'all';
        } else {
          YearChosen = selectedYear;
        }
        console.log("op CHANGED: year: " + YearChosen);

      })


      d3.select("#MaterialTypeSelectButton").on("change", function(d) {
        var selectedMType = d3.select(this).property("value");
        if(selectedMType == 'Select a material type') {
          MTypeChosen = 'all';
        } else {
          MTypeChosen = selectedMType;
        }
        console.log("op CHANGED: material type: " + MTypeChosen);

     })

console.log("op: year: " + YearChosen);
console.log("op: material type: " + MTypeChosen);
    requirement[0] = YearChosen;
    requirement[1] = MTypeChosen;
    d3.json(urls.artItems).then(drawArtItems);
    return requirement
}

function recordOneType(typeSet, matExactMap, original, nodes, typeName) {
  typeCount = 0;
  typeSetSize = typeSet.size;
  var typeItr = typeSet.entries();
  for(i=0;i<typeSetSize;i++){
    exactMaterial = typeItr.next().value[0];
    nodes.add(exactMaterial);

    exactList = [];
    exactList = matExactMap[exactMaterial];
//         console.log(exactMaterial);
        //  console.log(exactList);
    aitCount = exactList.length;

    original.push({
      'name' : exactMaterial,
      'parent' : typeName,
      'count' : aitCount,
      'leave' : 1
    })
    typeCount = typeCount + aitCount;
  }

  original.push({
    'name' : typeName,
    'parent' : 'root',
    'count' : typeCount,
    'leave' : typeCount
  })

  return typeCount;
}

function getTimeIntervalIndex(year) {
  //every 25 years
  //0: 1811-1835
  //1: 1836-1860
  //2: 1861-1885
  //3: 1886-1910
  //4: 1911-1935
  //5: 1936-1960
  //6: 1961-1985
  //7: 1986-2010
  //8: 2011-2035
  var yearValue = parseInt(year);

  var diff = yearValue - 1811;
  if(diff < 25) {
    return 0; //0: 1811-1835
  } else if(diff >= 25 && diff < 50){
    return 1; //1: 1836-1860
  } else if(diff >= 50 && diff < 75) {
    return 2; //2: 1861-1885
  } else if (diff >= 75 && diff < 100) {
    return 3; //3: 1886-1910
  } else if(diff >= 100 && diff < 125) {
    return 4;
  } else if(diff >= 125 && diff < 150) {
    return 5;
  } else if (diff >= 150 && diff < 175) {
    return 6;
  } else if (diff >= 175 && diff < 200) {
    return 7;
  } else if (diff >= 200 && diff < 225) {
    return 8;
  }

  return 9; //8 is for unkown year...

}


          function line() {
            d3.lineRadial()
              .curve(d3.curveBundle.beta(0.85))
              .radius(d => d.y)
              .angle(d => d.x)
          }

          function id(node) {
            return `${node.parent ? id(node.parent) + "." : ""}${node.data.name}`;
          }

          const tip = g.tooltip.append("text").attr("id", "tooltip");
          tip.attr("text-anchor", "end");
          tip.attr("dx", -5);
          tip.attr("dy", -5);
          tip.style("visibility", "hidden");

          // add details widget
          // https://bl.ocks.org/mbostock/1424037
          const details = g.details.append("foreignObject")
            .attr("id", "details")
            .attr("width", 500)
            .attr("height", 260)
            .attr("x", 728)
            .attr("y", 206);

          const body = details.append("xhtml:body")
            .style("text-align", "left")
            .style("background", "none")
            .html("<p>N/A</p>");

          details.style("visibility", "hidden");

          // setup projection
          // https://github.com/d3/d3-geo#geoConicEqualArea
          const projection = d3.geoConicEqualArea();
          projection.parallels([37.692514, 37.840699]);
          projection.rotate([122, 0]);

          // setup path generator (note it is a GEO path, not a normal path)
          const path = d3.geoPath().projection(projection);

          function drawBasemap(json) {
            jsonInputArray = [];
            console.log("basemap", json);

            const basemap = g.basemap.selectAll("path.land")
              .data(json.features)
              .enter()
              .append("path")
              .attr("d", path)
              .attr("class", "land");

            const outline = g.outline.selectAll("path.neighborhood")
                .data(json.features)
                .enter()
                .append("path")
                .attr("d", path)
                .attr("class", "neighborhood")
                .each(function(d) {
                  // save selection in data for interactivity
                  // saves search time finding the right outline later
                  d.properties.outline = this;
                });

            // add highlight
            basemap.on("mouseover.highlight", function(d) {
              d3.select(d.properties.outline).raise();
              d3.select(d.properties.outline).classed("active", true);
            })
            .on("mouseout.highlight", function(d) {
              d3.select(d.properties.outline).classed("active", false);
            });

            // add tooltip
      /*      basemap.on("mouseover.tooltip", function(d) {
              tip.text(d.properties.nhood);
              tip.style("visibility", "visible");
            })
            .on("mousemove.tooltip", function(d) {
              const coords = d3.mouse(g.basemap.node());
              tip.attr("x", coords[0]);
              tip.attr("y", coords[1]);
            })
            .on("mouseout.tooltip", function(d) {
              tip.style("visibility", "hidden");
            });
            */
          }

          function drawStreets(json) {
            console.log("streets", json);

            // only show active streets
            const streets = json.features.filter(function(d) {
              return d.properties.active;
            });

            console.log("removed", json.features.length - streets.length, "inactive streets");

            g.streets.selectAll("path.street")
              .data(streets)
              .enter()
              .append("path")
              .attr("d", path)
              .attr("class", "street");
          }

          function drawArtItems(json) {
            d3.selectAll("#allSymbols").remove();
            console.log('JSON for art items: ^^^^^^^^^^^^^^^^^^^');
            console.log(json);
            //if specific requirement, change set, otherwise use the default set...
            //according to queryReq, change the set range/content
            let acsSet = new Set();
            if (YearChosen == 'all') {
              if(MTypeChosen == 'all') {
                acsSet = YIMTmap['allYI']['all mType'];
              } else {
                acsSet = YIMTmap['allYI'][MTypeChosen];
              }
            } else {
              if(MTypeChosen == 'all') {
                acsSet = YIMTmap[YearChosen]['all mType'];
              } else {
                acsSet = YIMTmap[YearChosen][MTypeChosen];
              }
            }
            console.log("!!!!!!!!!!!!!!!!!!!!!!!current range: ");
            console.log(YearChosen + ", " + MTypeChosen +": ");
            console.log(acsSet);

            // loop through and add projected (x, y) coordinates
            // (just makes our d3 code a bit more simple later)
            count = 0;
            json.forEach(function(d) {
              if(!isNaN(d.latitude) && !isNaN(d.longitude)) {
                count++;
                const latitude = parseFloat(d.latitude);
                const longitude = parseFloat(d.longitude);
                const pixels = projection([longitude, latitude]);

                d.x = pixels[0];
                d.y = pixels[1];
              } else {
                d.x = -10;
                d.y = -10;
              }
              jsonInputArray.push({
                'Display Title': d.display_title,
                'Artist': d.artist,
                'Completion Year': d.creation_date,
                'Accession Number': d.accession_number,
                'Medium Detail': d.medium,
                'Latitude': d.latitude,
                'Longitude': d.longitude,
                'Address': d.street_address
              })


            });
            console.log("json input array:");
            console.log(jsonInputArray);

            // locMap[locString]    locString = row.Latitude + "&" + row.Longitude;   locAcsSet = locMap[locString]   locAcsSet.size

            const symbols = g.artItems.selectAll("circle")
              .data(json)
              .enter()
              .filter(d => (acsSet.has(d.accession_number)))
              .append("circle")
              .attr("id", "allSymbols")
              .attr("cx", function(d) { if(!isNaN(d.x))return d.x;})
              .attr("cy", function(d) { if(!isNaN(d.y))return d.y;})
              .attr("r", function(d) {
                locStr = d.latitude + "&" + d.longitude;

                if(locMap[locStr]) {
                  locSet = locMap[locStr];
                  //both in locSet and acsSet
                  var intersectionSet = locSet.intersection(acsSet);
                  caseCount = intersectionSet.size;


                  radius = (caseCount - 1) * 0.36 + 5;
                } else {
                  radius = 5;
                }
                return radius;
              })
              .attr("class", "symbol")
              .style("fill", "#e6b800");
      //      symbols.filter(d => (acsSet.has(d.AccessionNumber))).style("fill", "pink");
      //      console.log(d.AccessionNumber);


      symbols.on("click", function(d) {

            console.log('clicking symbol... ' + d.latitude + ", " + d.longitude);
            len = jsonInputArray.length;
            console.log('jsonInputArray');
            console.log(jsonInputArray);
            let resultSet = new Set();

            let chosenSymbolList = [];
            console.log('chosenSymbolList: ');
            console.log(chosenSymbolList);

            for(i=0;i<len;i++) {
              if(jsonInputArray[i]['Latitude'] == d.latitude
              && jsonInputArray[i]['Longitude'] == d.longitude
              && !resultSet.has(jsonInputArray[i]['Accession Number'])
              && acsSet.has(jsonInputArray[i]['Accession Number'])) {

                resultSet.add(jsonInputArray[i]['Accession Number']);
                chosenSymbolList.push({
                  'Display Title': jsonInputArray[i]['Display Title'],
                  'Artist': jsonInputArray[i]['Artist'],
                  'Completion Year': jsonInputArray[i]['Completion Year'],
                  'Accession Number': jsonInputArray[i]['Accession Number'],
                  'Medium Detail': jsonInputArray[i]['Medium Detail']
                })
              }
            }
            console.log('chosenSymbolList: ');
            console.log(chosenSymbolList);
            //chosenSymbolList display!!

            htmlSymbolItemList = `
            <title> Art Items at ${d.street_address}</title>
            <div style="overflow:auto">
              <table border="0" cellspacing="0" cellpadding="2"  style="height: 200px">
              <tbody>
              <tr>
                 <th>Display Title  </th>
                 <th>Artist  </th>
                 <th>Completion Year  </th>
                 <th>Medium Detail  </th>
                 <th>Accession Number  </th>
             </tr>`;

           for(j=0;j<chosenSymbolList.length;j++) {
             rowInfo = `<tr>
               <td>${chosenSymbolList[j][['Display Title']]}  </td>
               <td>${chosenSymbolList[j]['Artist']}  </td>
               <td>${chosenSymbolList[j]['Completion Year']}  </td>
               <td>${chosenSymbolList[j]['Medium Detail']}  </td>
               <td>${chosenSymbolList[j]['Accession Number']}  </td>
             </tr>`;
             htmlSymbolItemList = htmlSymbolItemList + rowInfo;
           }


           htmlSymbolItemList = htmlSymbolItemList
           +` </tbody>
            </table>
            </div>`;

            var win = window.open("", "", "toolbar=no,location=no,directories=no,status=no,menubar=no,scrollbars=yes,resizable=yes,width=980,height=300,top="+(screen.height-400)+",left="+(screen.width-840));
            win.document.body.innerHTML = htmlSymbolItemList;

            symbolChosen = true;

      });


            symbols.on("mouseover", function(d) {
              d3.select(this).raise();
              d3.select(this).classed("active", true);
              locStr = d.latitude + "&" + d.longitude;

              if(locMap[locStr]) {
                locSet = locMap[locStr]
                itemCount = locSet.size;

                locSet = locMap[locStr];
                //both in locSet and acsSet
                var intersectionSet = locSet.intersection(acsSet);
                caseCount = intersectionSet.size;
              } else {
                itemCount = 1;
              }

              // use template literal for the detail table
              // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Template_literals
              htmlSymbolDetail = `
                <table border="0" cellspacing="0" cellpadding="2">
                <tbody>
                <tr>
                  <th>Count of Art Item(s):</th>
                  <td>${caseCount}</td>
                </tr>
                <tr>
                  <th>Address:</th>
                  <td>${d.street_address}</td>
                </tr>
                <tr>
                  <th>Location Description:</th>
                  <td>${d.location_description}</td>
                </tr>
                <tr>
                  <th>Latitude, Longitude:</th>
                  <td>${d.latitude}, ${d.longitude}</td>
                </tr>


                `;
              htmlSymbolDetail  = htmlSymbolDetail +`

              </tbody>
              </table>`;

              body.html(htmlSymbolDetail);
              details.style("visibility", "visible");
            });


            symbols.on("mouseout", function(d) {
              d3.select(this).classed("active", false);
              details.style("visibility", "hidden");
            });

          }



          function drawCircleLegend() {
            /*
            38's r = 18.32
            29's r = 15.08
            19's r = 11.48
            9's r = 7.88
            radius = (caseCount - 1) * 0.36 + 5
            */

            const legendWidth = 150;
            const legendHeight = 50;

            // place legend in its own group
            const group = svg.append("g");
            group.attr('id', 'circle-legend');

            // shift legend to appropriate position
            group.attr('transform', translate(config.svg.width - config.margin.right - legendWidth - 30, config.margin.top - 10));

            const title = group.append('text')
              .text('Count of Art Items at the Location');
              title.attr('dx', -110);
              title.attr('dy', 20);

            const circ1 = group.append("circle")
              .attr("cx", -70)
              .attr("cy", 50)
              .attr("r", 18.32)
              .style("stroke", "silver")
              .style("fill", "#e6b800");

            const t1 = group.append('text')
              .text('38');
              t1.attr('dx', -82);
              t1.attr('dy', 85);

            const circ2 = group.append("circle")
              .attr("cx", -30)
              .attr("cy", 50)
              .attr("r", 15.08)
              .style("stroke", "silver")
              .style("fill", "#e6b800");

           const t2 = group.append('text')
              .text('29');
              t2.attr('dx', -41);
              t2.attr('dy', 85);

            const circ3 = group.append("circle")
              .attr("cx", 4)
              .attr("cy", 50)
              .attr("r", 11.48)
              .style("stroke", "silver")
              .style("fill", "#e6b800");

            const t3 = group.append('text')
              .text('19');
              t3.attr('dx', -6);
              t3.attr('dy', 85);

            const circ4 = group.append("circle")
              .attr("cx", 32)
              .attr("cy", 50)
              .attr("r", 7.88)
              .style("stroke", "silver")
              .style("fill", "#e6b800");
            const t4 = group.append('text')
                .text('9');
                t4.attr('dx', 26);
                t4.attr('dy', 85);

            const circ5 = group.append("circle")
              .attr("cx", 55)
              .attr("cy", 50)
              .attr("r", 5)
              .style("stroke", "silver")
              .style("fill", "#e6b800");

            const t5 = group.append('text')
                  .text('1');
              t5.attr('dx', 51);
              t5.attr('dy', 85);
          }


          function drawColorLegend() {
                 const legendWidth = 200;
                 const legendHeight = 20;

                 // place legend in its own group
                 const group = svg.append("g");
                 group.attr('id', 'color-legend');

                 // shift legend to appropriate position
                 group.attr('transform', translate(config.svg.width - config.margin.right - legendWidth - 30, config.margin.top - 10));

                 const title = group.append('text')
                   .attr('class', 'axis-title')
                   .text('Count of Current Material Used in Current Time Range');
                   title.attr('dx', -100);
                   title.attr('dy', 576);

                 const legendLabelMin = group.append('text')
                   .text('0')
                   .attr('dx', -45)
                   .attr('dy', 602);

                 const legendLabelMax = group.append('text')
                   .text('357')
                   .attr('dx', 185)
                   .attr('dy', 602);

                 // lets draw the rectangle, but it won't have a fill just yet
                 const colorbox = group.append('rect')
                   .attr('x', -25)
                   .attr('y', 586)
                   .attr('width', legendWidth)
                   .attr('height', legendHeight)
                   .style('stroke', 'silver');

                 // get the domain first (we do not want the middle value from the diverging scale)
                 const colorDomain = [d3.min(scale.color.domain()), d3.max(scale.color.domain())];

                 // add a new scale to go from color tick to percent
                 scale.percent = d3.scaleLinear()
                   .range([0, 100])
                   .domain(colorDomain);

                 // we have to first add gradients
                 const defs = svg.append('defs');

                 // add a color stop per data tick
                 // input  (ticks)   : [0.2, ..., 100, ..., 200.3]
                 // output (percents): [  0, ..., 50, ..., 100]
                 defs.append('linearGradient')
                   .attr('id', 'gradient')
                   .selectAll('stop')
                   .data(scale.color.ticks())
                   .enter()
                   .append('stop')
                   .attr('offset', d => scale.percent(d) + '%')
                   .attr('stop-color', d => scale.color(d));

                 // draw the color rectangle with the gradient
                 colorbox.attr('fill', 'url(#gradient)');


               }

          function translate(x, y) {
            return "translate(" + String(x) + "," + String(y) + ")";
          }

          Set.prototype.intersection = function(otherSet){
              // creating new set to store intersection
              var intersectionSet = new Set();

              // Iterate over the values
              for(var elem of otherSet)
              {
                  // if the other set contains a
                  // similar value as of value[i]
                  // then add it to intersectionSet
                  if(this.has(elem))
                      intersectionSet.add(elem);
              }

          // return values of intersectionSet
          return intersectionSet;
          }

</script>

      <h3> Encoding</h3>
      <p>On the proportional symbol map, the symbols are the locations of art items. Since sometimes there are multiple artworks at the same place, the count of art items is encoded by the size of the circle. Larger size of the circle symbol means more count of art items in that location. For the heat map, the x-axis is the time intervals from earlier to recent, and the y-axis are 6 types of materials used on art items. The color on the heatmap represents how many times that material was used. As shown in the legend, the more dark purple of a block means more counts of being used. </p>

      <h3> Interactivity</h3>
      <p> There are two drop down lists that work as filtering options, so after pressing the “check art items on the map” button, only the art items that fit the requirement would remain on the map. Also the heatmap would help as a chooser that can change values in drop down lists: hover a block on heatmap to see how many time that material was used in that range of time, and click one block to change the value in drop down lists, then click the “check art items on the map” button to see the filtered results. There is also a reset button, press “reset” and then press “check art items on the map” to resume the map that contains all symbols. For the symbol map, hover on a symbol to see how many art items are in that location, and click a symbol to get a pop up window for a table of information of artworks on that location in the query range.</p>

      <h3>Findings </h3>
      <p> <strong>Question: </strong> How is the distribution of artworks in terms of material type and over time? (Is there any trend or pattern?) </br>
        <strong>Answer: </strong> Artworks in this dataset were mostly created between the years of 1986-2010, and years close to that range. So we know that there are much more modern artworks than ancient art are on display in San Francisco. That actually surprised me because I’ve seen lots of ancient artworks in Asian Art Museum but it seems that those do not take up the major parts of the artworks in San Francisco.
       </p>


      <h3> Data Wrangling</h3>
      <p> For the generation of heatmap, when reading through the .csv file row by row, a map would be created to keep the records of raw data such as creation year, artist, medium, latitude, and longitude; then the counts as color encoding on heatmap would be implemented according to frequency of occurence in each range.
        For the classification of material types, all mediums of each art item would be splited up and form an array(since in most case there are multiple materials used in one art item), and each material as key in a map, could aggregate count of occurence in the art items. There are 6 main types of materials, and there is a map keeps records of counts for each material type, and an array of subtypes under it.
      Moreover, for the filtering on map visualization, the latitude + longitude would also work as keys in a map that keeps locations, to record information of all the art items at the same location.
      There is also an array works as a plain table for arbitrary query on original data without any requirement on information of current key-value pairs.</p>

      </div>
      <!-- End page content -->
    </div>
  </section>

  <!-- Page footer -->
  <!-- https://bulma.io/documentation/layout/footer/ -->
  <footer class="footer">
    <div class="content has-text-centered is-size-7">
      <p>
        <a href="#top">
          <span class="fas fa-arrow-up"></span>
          <span class="has-text-weight-medium">Back to Top</span>
        </a>
      </p>

      <p>
        <a href="https://github.com/usf-cs360-spring2020/project-alexziweiwang" class="button is-small" style="padding-left: 1em; padding-right: 1em;" target = _blank>
          <i class="fab fa-github-alt"></i>&nbsp;<strong>Github</strong>
        </a>

        <a href="https://fontawesome.com/" class="button is-small" style="padding-left: 1em; padding-right: 1em;">
          <i class="fab fa-font-awesome"></i>&nbsp;<strong>FontAwesome</strong>
        </a>

        <a href="https://bulma.io" class="button is-small">
          <img src="https://bulma.io/images/made-with-bulma--semiblack.png" alt="Made with Bulma" width="128" height="24">
        </a>
      </p>
    </div>
  </footer>
  <!-- End page footer -->
  </body>

</html>
