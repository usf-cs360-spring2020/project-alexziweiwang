<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">

    <title>Prototype Page - Beta</title>

    <!-- Load Bulma from CDN (consider saving it to repository instead) -->
    <!-- https://bulma.io/ -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bulma@0.8.0/css/bulma.min.css">

    <!-- Load Font Awesome 5 (free) icons -->
    <script defer src="https://use.fontawesome.com/releases/v5.3.1/js/all.js"></script>


    <style>
  #tooltip {
    font-weight: 600;
    text-shadow: 0px 0px 2px white;

    fill: orange;
    stroke: black;
  }

  path.land {
    fill: #dddddd;
    stroke: none;
  }

  path.neighborhood {
    fill: none;
    stroke: white;
    stroke-width: 3.5px;
    pointer-events: none;
  }

  path.street {
    fill: none;
    stroke: white;
    stroke-width: 1px;
    pointer-events: none;
  }

  .active {
    stroke: orange !important;
    stroke-width: 1.5px !important;
  }

  circle.symbol {
    fill-opacity: 0.8;

    stroke: white;
    stroke-width: 1px;
  }

  th {
    text-align: right;
  }

  .node {
    font: 10px sans-serif;
  }

  .link {
    stroke: steelblue;
    stroke-opacity: 0.5;
    fill: none;
    pointer-events: none;
  }


 </style>
  </head>

  <body>

  <!-- Page header -->
  <!-- https://bulma.io/documentation/layout/hero/ -->
  <section class="hero is-info is-bold">
    <div class="hero-body">
      <div class="container">
        <h1 class="title">Prototype Page - Beta</h1>
        <h2 class="subtitle">Visualization in d3.js</h2>
      </div>
    </div>
  </section>
  <!-- End page header -->

  <!-- Page navigation -->
  <!-- https://bulma.io/documentation/components/navbar/ -->
  <nav class="navbar is-light" role="navigation" aria-label="main navigation">
    <div class="container">
      <div class="navbar-brand">
        <a class="navbar-item is-active" href="index.html">
          <span class="icon"><i class="fas fa-home"></i></span>
          <span>Home</span>
        </a>

        <a role="button" class="navbar-burger burger" aria-label="menu" aria-expanded="false" data-target="main-menu">
          <span aria-hidden="true"></span>
          <span aria-hidden="true"></span>
          <span aria-hidden="true"></span>
        </a>
      </div>

      <div id="main-menu" class="navbar-menu has-text-weight-medium">
        <!-- Left navbar items -->
        <div class="navbar-start">
          <a class="navbar-item" href="dts.html" title="Data">
            <span class="icon"><i class="fas fa-table"></i></span>
            <span>Data</span>
          </a>

          <div class="navbar-item has-dropdown is-hoverable">
            <a class="navbar-link">
              Visualizations
            </a>

            <div class="navbar-dropdown">
              <a class="navbar-item" href="pttpAlpha.html">
                <span class="icon"><i class="fas fa-chart-line"></i></span>
                <span>Prototype-Alpha: non-proportional symbol map in Tableau</span>
              </a>

              <a class="navbar-item" href="pttpBeta1.html">
                <span class="icon"><i class="fas fa-chart-line"></i></span>
                <span>Prototype-Beta1: edge bundling diagram in d3.js</span>
              </a>

              <a class="navbar-item" href="pttpBeta2.html">
                <span class="icon"><i class="fas fa-chart-line"></i></span>
                <span>Prototype-Beta2: non-proportional symbol map in d3.js</span>
              </a>

            </div>
          </div>
        </div>

        <!-- Right navbar items -->
        <div class="navbar-end">
          <a class="navbar-item" href="abt.html" title="About">
            <span class="icon"><i class="fas fa-info-circle"></i></span>
            <span>About</span>
          </a>
        </div>
      </div>
    </div>
  </nav>
  <!-- End page navigation -->

  <section class="section">
    <div class="container">
      <!-- Begin page content -->
      <div class="content">

        <h1 class="title">
          Visualization in d3.js
        </h1>

        <meta charset="utf-8">
        <figure>
          <svg width="1260" height="500" id="vis">
            <g id="basemap"></g>

            <!-- turn off pointer events for certain groups -->
            <g id="streets" pointer-events="none"></g>
            <g id="outline" pointer-events="none"></g>

            <g id="artItems"></g>
            <g id="tooltip" pointer-events="none"></g>
            <g id="details" pointer-events="none"></g>
          </svg>

          <figcaption>
            Source: <a href="https://data.sfgov.org/Culture-and-Recreation/Civic-Art-Collection/7rjr-9n9w">Civic Art Collection</a>
          </figcaption>
        </figure>

        <script src="https://d3js.org/d3.v5.min.js"></script>

<script>

          const svg = d3.select("body").select("svg#vis");

          const g = {
            edgeBunddling: svg.select("g#edgeBunddling"),
            basemap: svg.select("g#basemap"),
            streets: svg.select("g#streets"),
            outline: svg.select("g#outline"),
            artItems: svg.select("g#artItems"),
            tooltip: svg.select("g#tooltip"),
            details: svg.select("g#details")
          };



          const pad = 14;
          const diameter = 500;
          const height = 500;
          const width = 1260;
          const r = 5;
/*
          var diameter = 960,
              radius = diameter / 2,
              innerRadius = radius - 120;

          var cluster = d3.cluster()
              .size([360, innerRadius]);

          var line = d3.radialLine()
              .curve(d3.curveBundle.beta(0.85))
              .radius(function(d) { return d.y; })
              .angle(function(d) { return d.x / 180 * Math.PI; });

          var link = svg.append("g").selectAll(".link"),
              node = svg.append("g").selectAll(".node");
*/




          let artistMap = [];
          var hrData = [];
          let hrMap = [];
          var countMap = [];

          countMap['root'] = 0;

          //Data wrangling ...
          const csv = "Civic_Art_Collection.csv";
          d3.csv(csv, recordArtist).then(makeHierarchyArray).then(drawHierarchyGraph);

          function recordArtist(row) {
            artistName = row['Artist'];
            artistName = artistName.replace(/ and /g, ';');
            artistName = artistName.replace(/, /g, ';');
            artistName = artistName.trim();
            artistNames = artistName.split(";");

            medium = row['Medium'].toLowerCase();;
            medium = medium.replace(/ and /g, ';');
            medium = medium.replace(/, /g, ';');
            medium = medium.trim();
            mediums = medium.split(';');

  //          console.log(artistName + " - " + medium);

            mediums.forEach(function addValue(d) {

              pd = d.trim();
    //          console.log("?? " + pd);

              if(hrMap[pd]) {
                artistNames.forEach(function addCurrMore(p) {
                    hrMap[pd].add(p);
                    if(countMap[p]) {
                      count = countMap[p];
      //                console.log("0" + count);

                      count ++;
                      countMap[p] = count;

                      mCount = countMap['root'];
                      mCount ++;
                      countMap['root'] = mCount;
                    } else {
                      countMap[p] = 1;
                    }


                })


      //          console.log("################# "+hrMap[pd]);
              } else {
                hrMap[pd] = new Set();
                artistNames.forEach(function addCurrNew(q) {
                    hrMap[pd].add(q);
                    if(countMap[q]) {
                      count = countMap[q];
            //          console.log("1" + count);
                      count ++;
                      countMap[q] = count;

                      mCount = countMap['root'];
                      mCount ++;
                      countMap['root'] = mCount;
                    } else {
                      countMap[q] = 1;
                    }

                })

              }



              if(countMap[pd]) {
                count = countMap[pd];
    //            console.log("2" + count);
                count ++;
                countMap[pd] = count;

              } else {
                countMap[pd] = 1;
              }
            }




            );
            return hrMap;

          }


          function makeHierarchyArray(map) {

//            console.log("map: " + hrMap.keys());
            for(var k in hrMap) {
        //      console.log("key: " + k);
              const iterator1 = hrMap[k].entries();
              arr = [];
              for (let entry of iterator1) {
                arr.push(entry);
                hrData.push({
                  name : entry[0],
                  parent : k,
                  count : countMap[entry[0]]
                });

              }

              hrData.push({
                name : k,
                parent : 'root',
                count : countMap[k]
              });

            }

            //TODO
            hrData.push({
              name : 'root',
              parent : "",
              count : countMap['root']
            });
            //TODO

            root = d3.stratify()
            .id(function(row) { return row.name; })
            .parentId(function(row) {
              return row.parent;
            })(hrData);

            console.log(root);





            return root;
          }

          function tree() { d3.cluster()
            .size([2 * Math.PI, radius - 100])
          }

          function toCartesian(r, theta) {
            return {
              x: r * Math.cos(theta),
              y: r * Math.sin(theta)
            };
          }


          function radialLine() {
            let generator = d3.linkRadial()
              .angle(d => d.theta + Math.PI / 2) // rotate, 0 angle is mapped differently here
              .radius(d => d.radial);

            return generator;
          }


          function drawHierarchyGraph(data) {
  //          const root = d3.tree(d3.hierarchy(data)
  //    data.sort((a, b) => d3.ascending(a.height, b.height) || d3.ascending(a.data.name, b.data.name));
//.sort((a, b) => d3.ascending(a.height, b.height) || d3.ascending(a.data.name, b.data.name))));


  //    let layout = d3.tree().size([2 * Math.PI, (500 / 2) - 15]);

/*
            const node = svg.append("g")
              .attr("font-family", "sans-serif")
              .attr("font-size", 10)
                .selectAll("g")
                .data(root.leaves())
                .join("g")
                    .append("text")
                    .attr("dy", "0.31em")
                    .attr("x", d => d.x < Math.PI ? 6 : -6)
                    .attr("text-anchor", d => d.x < Math.PI ? "start" : "end")
                    .attr("transform", d => d.x >= Math.PI ? "rotate(180)" : null)
                    .text(d => d.data.name)  ;


          const link = svg.append("g")
              .attr("stroke", 'blue')
              .attr("fill", "none")
            .selectAll("path")
        //    .data(root.leaves().flatMap(leaf => leaf.outgoing))
            .data(root.children)
            .join("path")
              .style("mix-blend-mode", "multiply")
              .attr("d", ([i, o]) => line(i.path(o)))
              .each(function(d) { d.path = this; });

          return svg.node();


*/
/*
  console.log(root);
  cluster(root);
console.log(root.leaves());

link = link
    .data(packageImports(root.leaves()))
    .enter().append("path")
      .each(function(d) { d.source = d[0], d.target = d[d.length - 1]; })
      .attr("class", "link")
      .attr("d", line);

  node = node
    .data(root.leaves())
    .enter().append("text")
      .attr("class", "node")
      .attr("dy", "0.31em")
      .attr("transform", function(d) { return "rotate(" + (d.x - 90) + ")translate(" + (d.y + 8) + ",0)" + (d.x < 180 ? "" : "rotate(180)"); })
      .attr("text-anchor", function(d) { return d.x < 180 ? "start" : "end"; })
      .text(function(d) { return d.data.key; });

*/

data.sort(function(a, b) {
   return b.height - a.height || b.count - a.count;
 });

 let layout = d3.cluster().size([2 * Math.PI, (diameter / 2) - pad]);

 layout(data);

 data.each(function(node) {
   node.theta = node.x;
   node.radial = node.y;

   var point = toCartesian(node.radial, node.theta);
   node.x = point.x;
   node.y = point.y;
 });


 let plot = svg.append("g")
    .attr("id", "plot")
    .attr("transform", translate(width / 2, height / 2));

//  drawLinks(plot.append("g"), data.links(), radialLine);
  drawNodes(plot.append("g"), data.descendants(), true);

  return svg.node();






          }

          function drawLinks(g, links, generator) {
            let paths = g.selectAll('path')
              .data(links)
              .enter()
              .append('path')
              .attr('d', generator)
              .attr('class', 'link');
          }

          function drawNodes(g, nodes, raise) {
            let circles = g.selectAll('circle')
              .data(nodes, node => node.data.name)
              .enter()
              .append('circle')
                .attr('r', d => d.r ? d.r : r)
                .attr('cx', d => d.x)
                .attr('cy', d => d.y)
                .attr('id', d => d.data.name)
                .attr('class', 'node');
          }

          function packageImports(nodes) {
            var map = {},
                imports = [];

            // Compute a map from name to node.
            nodes.forEach(function(d) {
              map[d.data.name] = d;
            });

            // For each import, construct a link from the source to target node.
            nodes.forEach(function(d) {
              if (d.data.imports) d.data.imports.forEach(function(i) {
                imports.push(map[d.data.name].path(map[i]));
              });
            });

            return imports;
          }

          function packageHierarchy(classes) {
            map = hrMap;
            function find(name, data) {
              var node = map[name], i;
              if (!node) {
                node = map[name] = data || {name: name, children: []};
                if (name.length) {
                  node.parent = find(name.substring(0, i = name.lastIndexOf(".")));
                  node.parent.children.push(node);
                  node.key = name.substring(i + 1);
                }
              }
              return node;
            }

            classes.forEach(function(d) {
              find(d.name, d);
            });

            return d3.hierarchy(map[""]);
          }




          function packageImports(nodes) {
            var map = {},
            imports = [];

            // Compute a map from name to node.
            nodes.forEach(function(d) {
              map[d.data.name] = d;
            });

            // For each import, construct a link from the source to target node.
            nodes.forEach(function(d) {
              if (d.data.imports) d.data.imports.forEach(function(i) {
                imports.push(map[d.data.name].path(map[i]));
              });
            });

            return imports;
}





          function line() {
            d3.lineRadial()
              .curve(d3.curveBundle.beta(0.85))
              .radius(d => d.y)
              .angle(d => d.x)
          }


          function id(node) {
            return `${node.parent ? id(node.parent) + "." : ""}${node.data.name}`;
          }





          function bilink(root) {
            const map = new Map(root.leaves().map(d => [id(d), d]));
            for (const d of root.leaves()) d.incoming = [], d.outgoing = d.data.imports.map(i => [d, map.get(i)]);
            for (const d of root.leaves()) for (const o of d.outgoing) o[1].incoming.push(o);
            return root;
          }













          function translate(x, y) {
            return "translate(" + String(x) + "," + String(y) + ")";
          }
</script>














  <p>Question: The exact question you are trying to answer with this prototype. Your prototype will be evaluated within the context of this question. For example, "is there a visible pattern of [metric] over [time range]" or "how does [some subcategory] compare to [another subcategory]" are good questions. However, "what [category] has the [largest/smallest] value of [some column]" can be answered with simple statistics and not a good question for visualization. For the best results, you should come up with a question first, then the prototype.

Answer: The answer to the question you were able to learn from the prototype. It is possible your prototype does not do a great job of answering your question---that is a positive result of this exercise. You need to iterate multiple different visualization techniques and designs of a single visualization to reach the final version!

Encoding: Describe how your visualization is encoded. Use precise visualization terminology, including the name of the overall visualization technique and the visual channels you are using to encode the data.

Interactivity: Describe your planned interactivity. Use precise visualization terminology to describe the type of interactivity, and what mouse or keyboard events will trigger that interactivity.


 </p>


        <h3>Encoding: </h3>
        <p> In this map visualization, each symbol on the map is an art item. Color is the medium of that art as shown in the legend.
        </p>

        <h3>Potential wrangling: </h3>
        <p> Since there are many mediums in the raw data, and there are actually groups of same mediums with slight different details, in the future the data could be merged into same large categories of mediums.
         For example, all the bronze, or all of the steel items could be merged into one larger "bronze" or "steel" group, and further filtering option could help for the subgroups.</p>

         <h3>Potential interactivities: </h3>
         <p> The symbols on the map could be designed as hovering by and show details such as artist, display titles, creation date and more. </P>
         <p> There could also be filtering options provided on the website, like by artist, by display, by creation date, or by medium. Then the user could look for art items conditionally.</p>

         <h2>Potential possibilities of other graphs: </h2>
         <p> There could be another graph according to the user's choice, so that the information of creation date could be applied in a time plot, maybe in a heatmap.</p>
         <p> As there are relationship of group and subgroup in the column of medium, there is also possibility of making a hierarchy graph. (For example metal -> Steel ->Painted Steel, etc.)</p>
      </div>
      <!-- End page content -->
    </div>
  </section>

  <!-- Page footer -->
  <!-- https://bulma.io/documentation/layout/footer/ -->
  <footer class="footer">
    <div class="content has-text-centered is-size-7">
      <p>
        <a href="#top">
          <span class="fas fa-arrow-up"></span>
          <span class="has-text-weight-medium">Back to Top</span>
        </a>
      </p>

      <p>
        <a href="https://github.com/usf-cs360-spring2020/project-alexziweiwang" class="button is-small" style="padding-left: 1em; padding-right: 1em;" target = _blank>
          <i class="fab fa-github-alt"></i>&nbsp;<strong>Github</strong>
        </a>

        <a href="https://fontawesome.com/" class="button is-small" style="padding-left: 1em; padding-right: 1em;">
          <i class="fab fa-font-awesome"></i>&nbsp;<strong>FontAwesome</strong>
        </a>

        <a href="https://bulma.io" class="button is-small">
          <img src="https://bulma.io/images/made-with-bulma--semiblack.png" alt="Made with Bulma" width="128" height="24">
        </a>
      </p>
    </div>
  </footer>
  <!-- End page footer -->
  </body>

</html>
