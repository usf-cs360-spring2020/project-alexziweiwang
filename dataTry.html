<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">

    <title>Data Trying page</title>

    <!-- Load Bulma from CDN (consider saving it to repository instead) -->
    <!-- https://bulma.io/ -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bulma@0.8.0/css/bulma.min.css">

    <!-- Load Font Awesome 5 (free) icons -->
    <script defer src="https://use.fontawesome.com/releases/v5.3.1/js/all.js"></script>


    <style>
  #tooltip {
    font-weight: 600;
    text-shadow: 0px 0px 2px white;

    fill: orange;
    stroke: black;
  }

  path.land {
    fill: #dddddd;
    stroke: none;
  }

  path.neighborhood {
    fill: none;
    stroke: white;
    stroke-width: 3.5px;
    pointer-events: none;
  }

  path.street {
    fill: none;
    stroke: white;
    stroke-width: 1px;
    pointer-events: none;
  }

  .active {
    stroke: orange !important;
    stroke-width: 1.5px !important;
  }

  circle.symbol {
    fill-opacity: 0.8;

    stroke: white;
    stroke-width: 1px;
  }

  th {
    text-align: right;
  }

  .node {
    font: 10px sans-serif;
  }

  .link {
    stroke: steelblue;
    stroke-opacity: 0.5;
    fill: none;
    pointer-events: none;
  }


 </style>
  </head>

  <body>

  <!-- Page header -->
  <!-- https://bulma.io/documentation/layout/hero/ -->
  <section class="hero is-info is-bold">
    <div class="hero-body">
      <div class="container">
        <h1 class="title">Data Trying page</h1>
        <h2 class="subtitle">Visualization in d3.js</h2>
      </div>
    </div>
  </section>
  <!-- End page header -->

  <!-- Page navigation -->
  <!-- https://bulma.io/documentation/components/navbar/ -->
  <nav class="navbar is-light" role="navigation" aria-label="main navigation">
    <div class="container">
      <div class="navbar-brand">
        <a class="navbar-item is-active" href="index.html">
          <span class="icon"><i class="fas fa-home"></i></span>
          <span>Home</span>
        </a>

        <a role="button" class="navbar-burger burger" aria-label="menu" aria-expanded="false" data-target="main-menu">
          <span aria-hidden="true"></span>
          <span aria-hidden="true"></span>
          <span aria-hidden="true"></span>
        </a>
      </div>

      <div id="main-menu" class="navbar-menu has-text-weight-medium">

      </div>
    </div>
  </nav>
  <!-- End page navigation -->

  <section class="section">
    <div class="container">
      <!-- Begin page content -->
      <div class="content">

        <h1 class="title">
          Visualization in d3.js
        </h1>

        <select id="YearIntercalSelectButton"></select>
        <select id="MaterialTypeSelectButton"></select>
        <button id="queryButton" onclick="queryButtonClicked()">check art items on the map</button>


        <meta charset="utf-8">
        <figure>
          <svg width="1260" height="500" id="vis">
            <g id="basemap"></g>

            <!-- turn off pointer events for certain groups -->
            <g id="streets" pointer-events="none"></g>
            <g id="outline" pointer-events="none"></g>

            <g id="artItems"></g>
            <g id="tooltip" pointer-events="none"></g>
            <g id="details" pointer-events="none"></g>
          </svg>

          <figcaption>
            Source: <a href="https://data.sfgov.org/Culture-and-Recreation/Civic-Art-Collection/7rjr-9n9w">Civic Art Collection</a>
          </figcaption>
        </figure>
        <script src="https://d3js.org/d3.v5.min.js"></script>
<script>

          // configuration of svg/plot area
          let config = {
            'svg': {},
            'margin': {},
            'plot': {}
          };

          config.svg.height = 900;
          config.svg.width = 1200; // golden ratio

          config.margin.top = 10;
          config.margin.right = 30;
          config.margin.bottom = 30;
          config.margin.left = 160;

          config.plot.x = config.margin.left - 60;
          config.plot.y = config.margin.top + 80;
          config.plot.width = config.svg.width - config.margin.left - config.margin.right;
          config.plot.height = config.svg.height - config.margin.top - config.margin.bottom - 720;

          // setup svg
          let svg = d3.select("body").select("svg#vis");
          svg.attr('width', config.svg.width);
          svg.attr('height', config.svg.height);

          // setup plot area
          let plot = svg.append('g');
          plot.attr('id', 'plot');
          plot.attr('transform', translate(config.plot.x, config.plot.y));

          // use a rect to illustrate plot area
          let rect = plot.append('rect');
          rect.attr('id', 'background');

          rect.attr('x', 0);
          rect.attr('y', 0);
          rect.attr('width', config.plot.width);
          rect.attr('height', config.plot.height);

          // scales for data
          let scale = {};

          scale.x = d3.scaleBand();
          scale.x.range([0, config.plot.width]);

          scale.y = d3.scaleBand();
          scale.y.range([config.plot.height, 0]);

          // https://github.com/d3/d3-scale-chromatic
          scale.color = d3.scaleSequential(d3.interpolateYlGnBu);

          let axis = {};  // axes for data
          axis.x = d3.axisBottom(scale.x);
          axis.x.tickPadding(0);

          axis.y = d3.axisLeft(scale.y);
          axis.y.tickPadding(0);

          let bcScale = {};
          let bcAxis = {};
          let bx, by;

          const pad = 14;
          const diameter = 500;
          const height = 500;
          const width = 1260;
          const r = 5;

                    let matExactMap = {};
                    let mTypeMap = {};
                    let materialSet = new Set();
                    let nodes = new Set();
                    let original = [];
                    let processed = [];
                    let timeMap = {};
                    timeMap['architectural material'] = [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0];
                    timeMap['metal'] = [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0];
                    timeMap['mineral'] = [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0];
                    timeMap['ecological'] = [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0];
                    timeMap['daily life object']  = [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0];
                    timeMap['kiln product'] = [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0];
                    let rawDataPlatTableArr = [];
                    let res = [];

                    nodes.add('root');
                    nodes.add('metal');
                    nodes.add('mineral');
                    nodes.add('ecological');
                    nodes.add('daily life object');
                    nodes.add('architectural material');
                    nodes.add('kiln product');
                    let typeName = ['architectural material', 'metal', 'mineral', 'ecological', 'daily life object', 'kiln product'];
                    let yearInterval = ['1811-1835', '1836-1860', '1861-1885', '1886-1910', '1911-1935',
                  '1936-1960', '1961-1985', '1986-2010', '2011-2035', 'unknown'];
                    //0: 1811-1835
                    //1: 1836-1860
                    //2: 1861-1885
                    //3: 1886-1910
                    //4: 1911-1935
                    //5: 1936-1960
                    //6: 1961-1985
                    //7: 1986-2010
                    //8: 2011-2035
                    let yearIntervaoOptions = ['Select a year interval','all','1811-1835', '1836-1860', '1861-1885', '1886-1910', '1911-1935',
                  '1936-1960', '1961-1985', '1986-2010', '2011-2035','unknown year'];
                    var optionYI = d3.select("#YearIntercalSelectButton")
                      .selectAll('myOptions')
                      .data(yearIntervaoOptions)
                      .enter()
                      .append('option')
                      .text(function (d) { console.log('??');return d; }) // text showed in the menu
                      .attr("value", function (d) { return d; }) // corresponding value returned by the button

                    let MaterialTypeOptions = ['Select a material type','all','architectural material', 'metal', 'mineral', 'ecological', 'daily life object', 'kiln product'];
                    var optionMT = d3.select("#MaterialTypeSelectButton")
                      .selectAll('myOptions')
                      .data(MaterialTypeOptions)
                      .enter()
                      .append('option')
                      .text(function (d) { console.log('??');return d; }) // text showed in the menu
                      .attr("value", function (d) { return d; }) // corresponding value returned by the button

                    let YearChosen = 'all';
                    let MTypeChosen = 'all';
                    let hmChosen = false;


                    let metalSet = new Set(["bronze", "steel", "gold leaf", "brass", "aluminum", "zinc", "copper", "bronzing powder", "metal", "copper leaf", "iron", "gold"]);
                    let mineralSet = new Set(["marble","granite", "terrazzo", "stone tiles", "cast stone", "soil", "lava rock", "stone", "basalt", "travertine", "graphite", "tesserae", "tuff stone", "stone boulder", "charcoal", "mortar",
                    "crystals", "minerals", "red porphyry", "onyx"]);
                    let ecoSet = new Set(["wood", "bone", "horn", "resin", "cotton", "plant", "oil", "wool", "planted earthwork", "wax", "bamboo", "ecological references", "water", "willow", "tule reed"]);

                    let dailyLifeSet = new Set(["loudspeakers","images","ink", "cables", "mirror", "video", "magnets", "electrical reed switches"
                    , "photogram", "wire", "egg tempera", "aero plate", "audiobox","electrical wiring",
                    "pencil", "paper", "digital print", "buttons", "jewelry", "recycled parking meter heads", "brass saxophones", "steel music panels", "shade cloth", "controller", "motors","electronics","recycled mirrors", "annotated library cards"]);

                    let architectureSet = new Set(["pigments","plastic mixture","paint", "mixed medium","plastic","led lighting","slate", "lighting", "asphalt","unknown", "mixed media relief","painted mural", "linoleum", "pigment", "architectural foam", "pigment print", "pastel", "archival pigment print", "cast aggregate", "mixed media color lino-cut print", "lacquer paint", "foam", "fabric collage", "soffits", "land scaping", "lino-cut print", "cement", "polyurethane foam",
                    "found objects", "plaster", "fresco", "concrete", "mixed media", "neon lighting", "argon lighting", "fluorescent lighting", "lacquer paints", "mirror tile", "abaca paper", "ink with gesso", "led", "mural",
                    "photography", "brick", "pipes", "polymer modified gypsum", "sisal rope"]);

                    let kilnSet = new Set(["glaze","ceramic beads","porcelain enamel","porcelain", "ceramic tile", "clay", "glass", "cast glass", "frosted glass", "mosaic tile", "enamel", "ceramic", "gilding", "enamel paint", "terracotta tile", "glass tiles", "glazed ceramic"
                    ,"crockery", "grout", "basaltic clay", "glass mosaic tile", "gfrc tile", "tile", "glass mosaic", "laminated digital print", "polyurethane paint"]);

                    const csvMat = "artcommision_categorized_material - Civic_Art_Collection.csv";
                    d3.csv(csvMat, recordMaterialInfo).then(makeDataFormat).then(drawAxis).then(drawHeatmap);
                  //.then(drawTitleCaptions);

                    function recordMaterialInfo(row) {
                      var materials = row.MediumMaterial;

                      var matArr = materials.split(",");
                      if(materials.length != 0) {
                        index = 0;
                        while (index < matArr.length) {
                          temp = matArr[index];
                          temp = temp.trim();
                          temp = temp.toLowerCase();
                          if(temp == "" || temp.length < 1) {
                            temp = "unknown";
                          }
                          materialSet.add(temp);

                          artist = row.Artist;
                          date = row.CreationFinishDate;
                          acsNumber = row.AccessionNumber;
                          mediumDetail = row.MediumDetail;
                          displayTitle = row.DisplayTitle;
                          latitude = row.Latitude;
                          longitude = row.Longitude;
                          nbh = row.SFFindNeighborhoods;
                          //metalSet, mineralSet, ecoSet, dailyLifeSet, architectureSet, kilnSet
                          timeArrIndex = getTimeIntervalIndex(date);

                          if(metalSet.has(temp)) {
                            mType = "metal";
                          } else if(mineralSet.has(temp)) {
                            mType = "mineral";
                          } else if(ecoSet.has(temp)) {
                            mType = "ecological";
                          } else if(dailyLifeSet.has(temp)) {
                            mType = "daily life object";
                          } else if(architectureSet.has(temp)) {
                            mType = "architectural material";
                          } else if(kilnSet.has(temp)) {
                            mType = "kiln product";
                          } else {
                            console.log("not having: ");
                            console.log(temp);
                          }

                          listTimeCount = timeMap[mType][timeArrIndex];
                          listTimeCount ++;
                          timeMap[mType][timeArrIndex] = listTimeCount;

                          if(matExactMap[temp]) {

                            currMatList = matExactMap[temp];
                            currMatList.push({
                              'Material': temp,
                              'Artist': artist,
                              'Completion Year': date,
                              'Accession Number': acsNumber,
                              'MediumDetail': mediumDetail,
                              'DisplayTitle': displayTitle,
                              'Latitude': latitude,
                              'Longitude': longitude,
                              'Material Type': mType
                            });
                            matExactMap[temp] = currMatList;
                          } else {
                            currMatList = [];

                            currMatList.push({
                              'Material': temp,
                              'Artist': artist,
                              'Completion Year': date,
                              'Accession Number': acsNumber,
                              'MediumDetail': mediumDetail,
                              'DisplayTitle': displayTitle,
                              'Latitude': latitude,
                              'Longitude': longitude,
                              'Material Type': mType
                            });
                            matExactMap[temp] = currMatList;
                          }

                          if(mTypeMap[mType]) {
                            typeSubMap = mTypeMap[mType];
                            if(typeSubMap[temp]) {
                              itemList = typeSubMap[temp];
                              itemList.push({
                                'Material': temp,
                                'Artist': artist,
                                'Completion Year': date,
                                'Accession Number': acsNumber,
                                'MediumDetail': mediumDetail,
                                'DisplayTitle': displayTitle,
                                'Latitude': latitude,
                                'Longitude': longitude,
                                'Material Type': mType
                              })
                              typeSubMap[temp]= itemList;
                            } else {
                              itemList = [];
                              itemList.push({
                                'Material': temp,
                                'Artist': artist,
                                'Completion Year': date,
                                'Accession Number': acsNumber,
                                'MediumDetail': mediumDetail,
                                'DisplayTitle': displayTitle,
                                'Latitude': latitude,
                                'Longitude': longitude,
                                'Material Type': mType
                              })
                              typeSubMap[temp]= itemList;

                            }
                            mTypeMap[mType] = typeSubMap;

                          } else {
                            typeSubMap = {};

                            itemList = [];
                            itemList.push({
                              'Material': temp,
                              'Artist': artist,
                              'Completion Year': date,
                              'Accession Number': acsNumber,
                              'MediumDetail': mediumDetail,
                              'DisplayTitle': displayTitle,
                              'Latitude': latitude,
                              'Longitude': longitude,
                              'Material Type': mType

                            })
                            typeSubMap[temp] = itemList;
                            mTypeMap[mType] = typeSubMap;
                          }


                          index++;
                        }
                      }
                      rawDataPlatTableArr.push({
                        'Artist': artist,
                        'Completion Year': date,
                        'Accession Number': acsNumber,
                        'MediumDetail': mediumDetail,
                        'DisplayTitle': displayTitle,
                        'Latitude': latitude,
                        'Longitude': longitude,
                        'Material Type': mType
                      })
                      return materialSet;

                    }


                    function makeDataFormat(data) {
                      console.log('materialSet: ');
                      console.log(materialSet);
                      console.log('mTypeMap: ');
                      console.log(mTypeMap);
                      console.log('timeMap: ');
                      console.log(timeMap);
                      console.log('rawDataPlatTableArr: ');
                      console.log(rawDataPlatTableArr);

          //metalSet, mineralSet, ecoSet, dailyLifeSet, architectureSet, kilnSet
                      allCount = 0; //count of leaves

                      archName = 'architectural material';
                      typeCount = recordOneType(architectureSet, matExactMap, original, nodes, archName);
                      allCount = allCount + typeCount;

                      metalName = "metal";
                      typeCount = recordOneType(metalSet, matExactMap, original, nodes, metalName);
                      allCount = allCount + typeCount;

                      mineralName = "mineral";
                      typeCount = recordOneType(mineralSet, matExactMap, original, nodes, mineralName);
                      allCount = allCount + typeCount;

                      ecoName = "ecological";
                      typeCount = recordOneType(ecoSet, matExactMap, original, nodes, ecoName);
                      allCount = allCount + typeCount;

                      dailyName = "daily life object";
                      typeCount = recordOneType(dailyLifeSet, matExactMap, original, nodes, dailyName);
                      allCount = allCount + typeCount;

                      kilnName = "kiln product";
                      typeCount = recordOneType(kilnSet, matExactMap, original, nodes, kilnName);
                      allCount = allCount + typeCount;

                      console.log(allCount);

                      i = 0;
                      while(i < 6) {
                        let oneRow = {};
                        oneRow.values = [];
                        count = 0;
                        type = typeName[i];
                        oneRow['type'] = type;

                        while(count < 10) {
                          oneRow.values.push({
                            'yearInterval': yearInterval[count],
                            'itemCount': timeMap[type][count],
                            'index': i
                          })
                          count ++;
                        }

                        res[i] = oneRow;
                        i ++;
                      }

                      console.log(res);
                      return res;
          }


          function drawAxis(data) {

                 console.log(data);

                 // now that we have data set the scale domain
                 scale.x.domain(yearInterval);
                 scale.y.domain(typeName);

                 // draw the x and y axis
                 let gx = svg.append('g');
                 gx.attr("id", "x-axis");
                 gx.attr("class", "axis");
                 plotX = config.plot.x;
                 plotYH = config.plot.y + config.plot.height;

                 gx.attr('transform', translate(plotX, plotYH));
                 gx.call(axis.x);

                 let gy = svg.append('g');
                 gy.attr("id", "y-axis");
                 gy.attr("class", "axis");

                 plotY = config.plot.y;

                 gy.attr('transform', translate(config.plot.x, config.plot.y));
                 gy.call(axis.y);

                 // add the options to the button

                 return data;
               }


               function drawHeatmap(data) {
                  //let typeName = ['architectural material', 'metal', 'mineral', 'ecological', 'daily life object', 'kiln product'];

                  allValues = timeMap['architectural material'].concat(timeMap['metal'],
                timeMap['mineral'], timeMap['ecological'], timeMap['daily life object'], timeMap['kiln product'])

                  allValues.sort((a,b)=>a-b);
                  console.log(allValues);
                  let min = d3.quantile(allValues, 0);
                  let q1 = d3.quantile(allValues, 0.25);
                  let median = d3.quantile(allValues, 0.5);
                  let q3 = d3.quantile(allValues, 0.75);
                  let max = d3.quantile(allValues, 1);

          //        scale.color.domain([min, q1, median, q3, max]);
          scale.color.domain([0, d3.max(allValues)]);

                  console.log(min +"; " + q1 + "; " + median + "; " + q3+ "; "+ max);


                  // create one group per row
                  let rows = plot.selectAll("g.cell")
                         .data(data)
                         .enter()
                         .append("g");
                       rows.attr("class", "cell");
                       rows.attr("transform", function(d) {
                         return translate(0, scale.y(d['type']));
                       });

                       let cells = rows.selectAll("rect")
                         .data(d => d.values)
                         .enter()
                         .append("rect");

                       cells.attr("x", d => scale.x(d.yearInterval));
                       cells.attr("y", 0); // handled by group transform
                       cells.attr("width", scale.x.bandwidth());
                       cells.attr("height", scale.y.bandwidth());

                       // here is the color magic!
                       cells.style("fill", d => scale.color(d.itemCount));

                       if(YearChosen != 'all' || MTypeChosen != 'all') {
                         typeIndex = 0;
                         for(i = 0; i < typeName.length; i++) {
                           if(typeName[i] == 'MTypeChosen') {
                             typeIndex = i;
                           }
                         }
                         cells.filter(d.yearInterval !== YearChosen).transition().style("fill", "silver");
                         cells.filter(d.yearInterval !== YearChosen).transition().style("stroke", "#e5e5e5").style("fill-opacity", "0.5");
                         cells.filter(d.index !== typeIndex).transition().style("fill", "silver");
                         cells.filter(d.index !== typeIndex).transition().style("stroke", "#e5e5e5").style("fill-opacity", "0.5");
                         cells.style("stroke", "gold");

                       }

                       cells.on("mouseover", function(d) {
                         d3.select(this)
                           .raise() // bring to front
                           .style("stroke", "orange")
                           .style("stroke-width", 5);

                       });

                       cells.on("mouseout", function(d) {

                         d3.select(this).style("stroke", null);
                       });

                       cells.on("click", function(d) {

                           YearChosen = d.yearInterval;
                           MTypeChosen = typeName[d.index];
                           optionYI.property("selected", function(d) {
                             return d === YearChosen;
                           });

                           optionMT.property("selected", function(d) {
                             return d === MTypeChosen;
                           });

                           console.log("hm: year: " + YearChosen);
                           console.log("hm: material type: " + MTypeChosen);

                       });

                     }

                     d3.select("#YearIntercalSelectButton").on("change", function(d) {
                       var selectedYear = d3.select(this).property("value");
                       if(selectedYear == 'Select a year interval') {
                         YearChosen = 'all';
                       } else {
                         YearChosen = selectedYear;
                       }
                       console.log("op CHANGED: year: " + YearChosen);

                     })


                     d3.select("#MaterialTypeSelectButton").on("change", function(d) {
                       var selectedMType = d3.select(this).property("value");
                       if(selectedMType == 'Select a material type') {
                         MTypeChosen = 'all';
                       } else {
                         MTypeChosen = selectedMType;
                       }
                       console.log("op CHANGED: material type: " + MTypeChosen);

                    })


          function queryButtonClicked() {
              //YearIntercalSelectButton
              //MaterialTypeSelectButton


              console.log("query button clicked!!");

                d3.select("#YearIntercalSelectButton").on("change", function(d) {
                  var selectedYear = d3.select(this).property("value");
                  if(selectedYear == 'Select a year interval') {
                    YearChosen = 'all';
                  } else {
                    YearChosen = selectedYear;
                  }
                  console.log("op CHANGED: year: " + YearChosen);

                })


                d3.select("#MaterialTypeSelectButton").on("change", function(d) {
                  var selectedMType = d3.select(this).property("value");
                  if(selectedMType == 'Select a material type') {
                    MTypeChosen = 'all';
                  } else {
                    MTypeChosen = selectedMType;
                  }
                  console.log("op CHANGED: material type: " + MTypeChosen);

               })


      /*       } else {
               optionYI.property("selected", function(d) {
                 return d === 'Select a year interval';
               });

               optionMT.property("selected", function(d) {
                 return d === 'Select a material type';
               });
             }*/

//'Select a year interval' optionYI  'Select a material type' optionMT

console.log("op: year: " + YearChosen);
console.log("op: material type: " + MTypeChosen);

//'Select a year interval'  'Select a material type'
          }




          function recordOneType(typeSet, matExactMap, original, nodes, typeName) {
            typeCount = 0;
            typeSetSize = typeSet.size;
            var typeItr = typeSet.entries();
            for(i=0;i<typeSetSize;i++){
              exactMaterial = typeItr.next().value[0];
              nodes.add(exactMaterial);

              exactList = [];
              exactList = matExactMap[exactMaterial];
    //         console.log(exactMaterial);
    //          console.log(exactList);

              original.push({
                'name' : exactMaterial,
                'count' : exactList.length,
                'leave' : 1
              })
              typeCount ++;
            }
            original.push({
              'name' : typeName,
              'count' : typeCount,
              'leave' : typeCount
            })

            return typeCount;
          }

          function getTimeIntervalIndex(year) {
            //every 25 years
            //0: 1811-1835
            //1: 1836-1860
            //2: 1861-1885
            //3: 1886-1910
            //4: 1911-1935
            //5: 1936-1960
            //6: 1961-1985
            //7: 1986-2010
            //8: 2011-2035
            var yearValue = parseInt(year);

            var diff = yearValue - 1811;
            if(diff < 25) {
              return 0; //0: 1811-1835
            } else if(diff >= 25 && diff < 50){
              return 1; //1: 1836-1860
            } else if(diff >= 50 && diff < 75) {
              return 2; //2: 1861-1885
            } else if (diff >= 75 && diff < 100) {
              return 3; //3: 1886-1910
            } else if(diff >= 100 && diff < 125) {
              return 4;
            } else if(diff >= 125 && diff < 150) {
              return 5;
            } else if (diff >= 150 && diff < 175) {
              return 6;
            } else if (diff >= 175 && diff < 200) {
              return 7;
            } else if (diff >= 200 && diff < 225) {
              return 8;
            }

            return 9; //8 is for unkown year...

          }




          function tree() { d3.cluster()
            .size([2 * Math.PI, radius - 100])
          }

          function toCartesian(r, theta) {
            return {
              x: r * Math.cos(theta),
              y: r * Math.sin(theta)
            };
          }

          function radialLine() {
            let generator = d3.linkRadial()
              .angle(d => d.theta + Math.PI / 2) // rotate, 0 angle is mapped differently here
              .radius(d => d.radial);

            return generator;
          }

          function line() {
            d3.lineRadial()
              .curve(d3.curveBundle.beta(0.85))
              .radius(d => d.y)
              .angle(d => d.x)
          }


          function id(node) {
            return `${node.parent ? id(node.parent) + "." : ""}${node.data.name}`;
          }

          function bilink(Root) {
            const map = new Map(Root.leaves().map(d => [id(d), d]));
            for (const d of Root.leaves()) d.incoming = [], d.outgoing = d.data.imports.map(i => [d, map.get(i)]);
            for (const d of Root.leaves()) for (const o of d.outgoing) o[1].incoming.push(o);
            return Root;
          }













          function translate(x, y) {
            return "translate(" + String(x) + "," + String(y) + ")";
          }
</script>















  <h3>Question: </h3>
  <p> Is there any clustering of artists that use similar materials as medium of art items and how are the artists connected to each other by such similarity?</p>

  <h3>Answer: </h3>
  <p> </p>


  <h3>Encoding: </h3>
  <P> The visualization would be in the edge bundling diagram that the leaves would be artists, and parent node would be mediums/materials. Then artists use same kind of mediums/materials would be with bundled edges.</p>


  <h3>Interactivity: </h3>
  <p> If the user choose to see a type of medium(material) or an artist on the map, only symbols that are under this category would remain on this geospatial data visualization, and relative edge-bundling graph would also show up.</p>




 </p>


      </div>
      <!-- End page content -->
    </div>
  </section>

  <!-- Page footer -->
  <!-- https://bulma.io/documentation/layout/footer/ -->
  <footer class="footer">
    <div class="content has-text-centered is-size-7">
      <p>
        <a href="#top">
          <span class="fas fa-arrow-up"></span>
          <span class="has-text-weight-medium">Back to Top</span>
        </a>
      </p>

      <p>
        <a href="https://github.com/usf-cs360-spring2020/project-alexziweiwang" class="button is-small" style="padding-left: 1em; padding-right: 1em;" target = _blank>
          <i class="fab fa-github-alt"></i>&nbsp;<strong>Github</strong>
        </a>

        <a href="https://fontawesome.com/" class="button is-small" style="padding-left: 1em; padding-right: 1em;">
          <i class="fab fa-font-awesome"></i>&nbsp;<strong>FontAwesome</strong>
        </a>

        <a href="https://bulma.io" class="button is-small">
          <img src="https://bulma.io/images/made-with-bulma--semiblack.png" alt="Made with Bulma" width="128" height="24">
        </a>
      </p>
    </div>
  </footer>
  <!-- End page footer -->
  </body>

</html>
