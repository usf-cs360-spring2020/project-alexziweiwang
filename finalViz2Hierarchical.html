<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">

    <title>Final Visualization 2: Hierarchical Relationship - Types of Materials Used on Art Items in San Francisco</title>

    <!-- Load Bulma from CDN (consider saving it to repository instead) -->
    <!-- https://bulma.io/ -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bulma@0.8.0/css/bulma.min.css">

    <!-- Load Font Awesome 5 (free) icons -->
    <script defer src="https://use.fontawesome.com/releases/v5.3.1/js/all.js"></script>


    <style>

  #symbolList {
    overflow-y: scroll;
  }

  #ResetButton {
    font-size: 12px;
  }

  #YearIntercalSelectButton {
    font-size: 16px;
  }
  #MaterialTypeSelectButton {
    font-size: 16px;
  }
  #queryButton {
    font-size: 16px;
  }

  .axis {
    font: 16px sans-serif;
  }
  #tooltip {
    font-weight: 600;
    text-shadow: 0px 0px 2px white;

    fill: orange;
    stroke: black;
  }

  path.land {
    fill: #dddddd;
    stroke: none;
  }

  path.neighborhood {
    fill: none;
    stroke: white;
    stroke-width: 3.5px;
    pointer-events: none;
  }

  path.street {
    fill: none;
    stroke: white;
    stroke-width: 1px;
    pointer-events: none;
  }

  .active {
    stroke: orange !important;
    stroke-width: 1.5px !important;
  }

  circle.symbol {
    fill-opacity: 0.7;

    stroke: white;
    stroke-width: 1px;
  }

  th {
    text-align: right;
  }


 </style>

</head>

  <body>

  <!-- Page header -->
  <!-- https://bulma.io/documentation/layout/hero/ -->
  <section class="hero is-info is-bold">
    <div class="hero-body">
      <div class="container">
        <h1 class="title">Final Visualization 2: Hierarchical Relationship - Types of Materials Used on Art Items in San Francisco</h1>
        <h2 class="subtitle">Visualization in d3.js</h2>
      </div>
    </div>
  </section>
  <!-- End page header -->

  <!-- Page navigation -->
  <!-- https://bulma.io/documentation/components/navbar/ -->
  <nav class="navbar is-light" role="navigation" aria-label="main navigation">
    <div class="container">
      <div class="navbar-brand">
        <a class="navbar-item is-active" href="index.html">
          <span class="icon"><i class="fas fa-home"></i></span>
          <span>Home</span>
        </a>

        <a role="button" class="navbar-burger burger" aria-label="menu" aria-expanded="false" data-target="main-menu">
          <span aria-hidden="true"></span>
          <span aria-hidden="true"></span>
          <span aria-hidden="true"></span>
        </a>
      </div>

      <div id="main-menu" class="navbar-menu has-text-weight-medium">
        <!-- Left navbar items -->
        <div class="navbar-start">
          <a class="navbar-item" href="dts.html" title="Data">
            <span class="icon"><i class="fas fa-table"></i></span>
            <span>Data</span>
          </a>

          <div class="navbar-item has-dropdown is-hoverable">
            <a class="navbar-link">
              Visualizations
            </a>

            <div class="navbar-dropdown">

              <a class="navbar-item" href="pttpAlpha.html">
                <span class="icon"><i class="fas fa-chart-line"></i></span>
                <span>Prototype-Alpha: Art Items on Map of San Francisco - Non-proportional Symbol Map in Tableau (with feedback)</span>
              </a>

              <a class="navbar-item" href="pttpBeta2.html">
                <span class="icon"><i class="fas fa-chart-line"></i></span>
                <span>Prototype-Beta-OverallMap:  Clustering of Artists that Use Similar Materials? - non-proportional symbol map in d3.js (with feedback)</span>
              </a>

              <a class="navbar-item" href="finalViz1mapHm.html">
                <span class="icon"><i class="fas fa-chart-line"></i></span>
                <span>Final Visualization 1: Distribution Over Time - Materials Used on Art Items in San Francisco</span>
              </a>

              <a class="navbar-item" href="finalViz2Hierarchical.html">
                <span class="icon"><i class="fas fa-chart-line"></i></span>
                <span>Final Visualization 2: Hierarchical Relationship - Types of Materials Used on Art Items in San Francisco </span>
              </a>



            </div>
          </div>
        </div>

        <!-- Right navbar items -->
        <div class="navbar-end">
          <a class="navbar-item" href="abt.html" title="About">
            <span class="icon"><i class="fas fa-info-circle"></i></span>
            <span>About</span>
          </a>
        </div>
      </div>
    </div>
  </nav>
  <!-- End page navigation -->

  <section class="section">
    <div class="container">
      <!-- Begin page content -->
      <div class="content">

        <h1 class="title">
          Proportional Symbol Map & Node-link Diagram
        </h1>

        <meta charset="utf-8">
        <figure>
          <svg width="1260" height="600" id="vis">
            <g id="basemap"></g>

            <!-- turn off pointer events for certain groups -->
            <g id="streets" pointer-events="none"></g>
            <g id="outline" pointer-events="none"></g>

            <g id="artItems"></g>
            <g id="tooltip" pointer-events="none"></g>
            <g id="details" pointer-events="none"></g>

          </svg>

          <figcaption>
            Source: <a href="https://data.sfgov.org/Culture-and-Recreation/Civic-Art-Collection/7rjr-9n9w">Civic Art Collection</a>
            (<a href="https://data.sfgov.org/Geographic-Locations-and-Boundaries/Analysis-Neighborhoods/p5b7-5n3h">Neighborhoods</a>, <a href="https://data.sfgov.org/Geographic-Locations-and-Boundaries/Streets-Active-and-Retired/3psu-pn9h">Streets</a>)
          </figcaption>
        </figure>

        <script src="https://d3js.org/d3.v5.min.js"></script>

<script>



    const width = 1440;
    const height = 800;


    // setup svg
    let svg = d3.select("body").select("svg#vis");
    svg.attr('width', width);
    svg.attr('height', height);


    const urls = {
      basemap: "https://data.sfgov.org/resource/xfcw-9evu.geojson",
      streets: "https://data.sfgov.org/resource/3psu-pn9h.geojson?$limit=8000",
      artItems: "https://data.sfgov.org/resource/7rjr-9n9w.json"
    };

    // calculate date range
    const end = d3.timeDay.floor(d3.timeDay.offset(new Date(), -1));
    const start = d3.timeDay.floor(d3.timeDay.offset(end, -7));
    const format = d3.timeFormat("%Y-%m-%dT%H:%M:%S");
    console.log(format(start), format(end));

    urls.artItems = 'https://data.sfgov.org/resource/7rjr-9n9w.json';

    console.log(urls.artItems);

    const g = {
      edgeBunddling: svg.select("g#edgeBunddling"),
      basemap: svg.select("g#basemap"),
      streets: svg.select("g#streets"),
      outline: svg.select("g#outline"),
      artItems: svg.select("g#artItems"),
      tooltip: svg.select("g#tooltip"),
      details: svg.select("g#details")
    };


              const pad = 15;
              const r = 10;
              const diameter = 500;
              const color = d3.scaleSequential(d3.interpolateGnBu);
              //interpolateGnBu
              color.domain([0,235,471,706,942]);
              let matExactMap = {};
              let mTypeMap = {};
              let materialSet = new Set();
              let nodes = new Set();
              let original = [];
              let processed = [];
              let timeMap = {};
              let YIMTmap = {};
              let locMap = {};
              let acsSet = new Set();
              timeMap['architectural material'] = [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0];
              timeMap['metal'] = [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0];
              timeMap['mineral'] = [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0];
              timeMap['ecological'] = [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0];
              timeMap['daily life object']  = [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0];
              timeMap['kiln product'] = [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0];
              let rawDataPlatTableArr = [];
              let res = [];

              nodes.add('root');
              nodes.add('metal');
              nodes.add('mineral');
              nodes.add('ecological');
              nodes.add('daily life object');
              nodes.add('architectural material');
              nodes.add('kiln product');
              let typeName = ['architectural material', 'metal', 'mineral', 'ecological', 'daily life object', 'kiln product'];
              let yearInterval = ['1811-1835', '1836-1860', '1861-1885', '1886-1910', '1911-1935',
            '1936-1960', '1961-1985', '1986-2010', '2011-2035', 'unknown year'];
              //0: 1811-1835
              //1: 1836-1860
              //2: 1861-1885
              //3: 1886-1910
              //4: 1911-1935
              //5: 1936-1960
              //6: 1961-1985
              //7: 1986-2010
              //8: 2011-2035
              let yearIntervaoOptions = ['Select a year interval','all','1811-1835', '1836-1860', '1861-1885', '1886-1910', '1911-1935',
            '1936-1960', '1961-1985', '1986-2010', '2011-2035','unknown year'];
              var optionYI = d3.select("#YearIntercalSelectButton")
                .selectAll('myOptions')
                .data(yearIntervaoOptions)
                .enter()
                .append('option')
                .text(function (d) { return d; }) // text showed in the menu
                .attr("value", function (d) { return d; }) // corresponding value returned by the button

              let MaterialTypeOptions = ['Select a material type','all','architectural material', 'metal', 'mineral', 'ecological', 'daily life object', 'kiln product'];
              var optionMT = d3.select("#MaterialTypeSelectButton")
                .selectAll('myOptions')
                .data(MaterialTypeOptions)
                .enter()
                .append('option')
                .text(function (d) { return d; }) // text showed in the menu
                .attr("value", function (d) { return d; }) // corresponding value returned by the button
    //'Select a year interval'  'Select a material type'
              let YearChosen = 'all';
              let MTypeChosen = 'all';
              let hmChosen = false;

              let jsonInputArray = [];
              let metalSet = new Set(["bronze", "steel", "gold leaf", "brass", "aluminum", "zinc", "copper", "bronzing powder", "metalmaterial", "copper leaf", "iron", "gold"]);
              let mineralSet = new Set(["marble","granite", "terrazzo", "stone tiles", "cast stone", "soil", "lava rock", "stone", "basalt", "travertine", "graphite", "tesserae", "tuff stone", "stone boulder", "charcoal", "mortar",
              "crystals", "minerals", "red porphyry", "onyx"]);
              let ecoSet = new Set(["wood", "bone", "horn", "resin", "cotton", "plant", "oil", "wool", "planted earthwork", "wax", "bamboo", "ecological references", "water", "willow", "tule reed"]);

              let dailyLifeSet = new Set(["loudspeakers","images","ink", "cables", "mirror", "video", "magnets", "electrical reed switches"
              , "photogram", "wire", "egg tempera", "aero plate", "audiobox","electrical wiring",
              "pencil", "paper", "digital print", "buttons", "jewelry", "recycled parking meter heads", "brass saxophones", "steel music panels", "shade cloth", "controller", "motors","electronics","recycled mirrors", "annotated library cards"]);

              let architectureSet = new Set(["pigments","plastic mixture","paint", "mixed medium","plastic","led lighting","slate", "lighting", "asphalt","unknown", "mixed media relief","painted mural", "linoleum", "pigment", "architectural foam", "pigment print", "pastel", "archival pigment print", "cast aggregate", "mixed media color lino-cut print", "lacquer paint", "foam", "fabric collage", "soffits", "land scaping", "lino-cut print", "cement", "polyurethane foam",
              "found objects", "plaster", "fresco", "concrete", "mixed media", "neon lighting", "argon lighting", "fluorescent lighting", "lacquer paints", "mirror tile", "abaca paper", "ink with gesso", "led", "mural",
              "photography", "brick", "pipes", "polymer modified gypsum", "sisal rope"]);

              let kilnSet = new Set(["glaze","ceramic beads","porcelain enamel","porcelain", "ceramic tile", "clay", "glass", "cast glass", "frosted glass", "mosaic tile", "enamel", "ceramic", "gilding", "enamel paint", "terracotta tile", "glass tiles", "glazed ceramic"
              ,"crockery", "grout", "basaltic clay", "glass mosaic tile", "gfrc tile", "tile", "glass mosaic", "laminated digital print", "polyurethane paint"]);

              const csvMat = "artcommision_categorized_material - Civic_Art_Collection.csv";
    d3.csv(csvMat, recordMaterialInfo).then(makeCirTreeDataFormat).then(cirtree).then(drawColorLegend);
    d3.json(urls.basemap).then(function(json) {
      // makes sure to adjust projection to fit all of our regions
      projection.fitSize([960, 600], json);

      // draw the land and neighborhood outlines
      drawBasemap(json);

      // now that projection has been set trigger loading the other files
      // note that the actual order these files are loaded may differ
      d3.json(urls.streets).then(drawStreets);
      d3.json(urls.artItems).then(drawArtItems);
    });

              function recordMaterialInfo(row) {
                var materials = row.MediumMaterial;

                var matArr = materials.split(",");
                if(materials.length != 0) {
                  index = 0;
                  while (index < matArr.length) {
                    temp = matArr[index];
                    temp = temp.trim();
                    temp = temp.toLowerCase();
                    if(temp == "" || temp.length < 1) {
                      temp = "unknown";
                    }
                    materialSet.add(temp);

                    artist = row.Artist;
                    date = row.CreationFinishDate;
                    acsNumber = row.AccessionNumber;
                    mediumDetail = row.MediumDetail;
                    displayTitle = row.DisplayTitle;
                    latitude = row.Latitude;
                    longitude = row.Longitude;
                    nbh = row.SFFindNeighborhoods;
                    locString = row.Latitude + "&" + row.Longitude;

                    acsSet.add(acsNumber);

                    if(locMap[locString]) {
                      locAcsSet = locMap[locString];
                      locAcsSet.add(acsNumber);
                      locMap[locString] = locAcsSet;
      //            console.log(locAcsSet.size);
                    } else { //ne wkey value locString
                      locAcsSet = new Set();
                      locAcsSet.add(acsNumber);
                      locMap[locString] = locAcsSet;
                    }
                //    console.log('locMap: ');

          //          console.log(locMap);
    // locMap[locString]    locString = row.Latitude + "&" + row.Longitude;   locAcsSet = locMap[locString]   locAcsSet.size



    //locMap
                    //metalSet, mineralSet, ecoSet, dailyLifeSet, architectureSet, kilnSet
                    timeArrIndex = getTimeIntervalIndex(date);
                    currYearInterval = yearInterval[timeArrIndex];


                    if(metalSet.has(temp)) {
                      mType = "metal";
                    } else if(mineralSet.has(temp)) {
                      mType = "mineral";
                    } else if(ecoSet.has(temp)) {
                      mType = "ecological";
                    } else if(dailyLifeSet.has(temp)) {
                      mType = "daily life object";
                    } else if(architectureSet.has(temp)) {
                      mType = "architectural material";
                    } else if(kilnSet.has(temp)) {
                      mType = "kiln product";
                    } else {
                      console.log("not having: ");
                      console.log(temp);
                    }

                    if(temp == 'metal') {
                      console.log("@@@@@@@@@@@@@@@@@"+acsNumber);
                    }

                    listTimeCount = timeMap[mType][timeArrIndex];
                    listTimeCount ++;
                    timeMap[mType][timeArrIndex] = listTimeCount;

                    if(matExactMap[temp]) {

                      currMatList = matExactMap[temp];
                      currMatList.push({
                        'Material': temp,
                        'Artist': artist,
                        'Completion Year': date,
                        'Accession Number': acsNumber,
                        'MediumDetail': mediumDetail,
                        'DisplayTitle': displayTitle,
                        'Latitude': latitude,
                        'Longitude': longitude,
                        'Material Type': mType,
                        'Year Interval': currYearInterval
                      });
                      matExactMap[temp] = currMatList;
                    } else {
                      currMatList = [];

                      currMatList.push({
                        'Material': temp,
                        'Artist': artist,
                        'Completion Year': date,
                        'Accession Number': acsNumber,
                        'MediumDetail': mediumDetail,
                        'DisplayTitle': displayTitle,
                        'Latitude': latitude,
                        'Longitude': longitude,
                        'Material Type': mType,
                        'Year Interval': currYearInterval
                      });
                      matExactMap[temp] = currMatList;
                    }

                    if(mTypeMap[mType]) {
                      typeSubMap = mTypeMap[mType];
                      if(typeSubMap[temp]) {
                        itemList = typeSubMap[temp];
                        itemList.push({
                          'Material': temp,
                          'Artist': artist,
                          'Completion Year': date,
                          'Accession Number': acsNumber,
                          'MediumDetail': mediumDetail,
                          'DisplayTitle': displayTitle,
                          'Latitude': latitude,
                          'Longitude': longitude,
                          'Material Type': mType,
                          'Year Interval': currYearInterval
                        })
                        typeSubMap[temp]= itemList;
                      } else {
                        itemList = [];
                        itemList.push({
                          'Material': temp,
                          'Artist': artist,
                          'Completion Year': date,
                          'Accession Number': acsNumber,
                          'MediumDetail': mediumDetail,
                          'DisplayTitle': displayTitle,
                          'Latitude': latitude,
                          'Longitude': longitude,
                          'Material Type': mType,
                          'Year Interval': currYearInterval
                        })
                        typeSubMap[temp]= itemList;

                      }
                      mTypeMap[mType] = typeSubMap;

                    } else {
                      typeSubMap = {};

                      itemList = [];
                      itemList.push({
                        'Material': temp,
                        'Artist': artist,
                        'Completion Year': date,
                        'Accession Number': acsNumber,
                        'MediumDetail': mediumDetail,
                        'DisplayTitle': displayTitle,
                        'Latitude': latitude,
                        'Longitude': longitude,
                        'Material Type': mType,
                        'Year Interval': currYearInterval

                      })
                      typeSubMap[temp] = itemList;
                      mTypeMap[mType] = typeSubMap;
                    }


                    index++;
                  }
                }
                rawDataPlatTableArr.push({
                  'Artist': artist,
                  'Completion Year': date,
                  'Accession Number': acsNumber,
                  'MediumDetail': mediumDetail,
                  'DisplayTitle': displayTitle,
                  'Latitude': latitude,
                  'Longitude': longitude,
                  'Material Type': mType,
                  'Year Interval': currYearInterval
                })
                return materialSet;

              }



              function makeCirTreeDataFormat(data) {
                console.log('matExactMap: ');
                console.log(matExactMap);
                console.log('materialSet: ');
                console.log(materialSet);
                console.log('mTypeMap: ');
                console.log(mTypeMap);

                console.log('rawDataPlatTableArr: ');
                console.log(rawDataPlatTableArr);


              //metalSet, mineralSet, ecoSet, dailyLifeSet, architectureSet, kilnSet
                allCount = 0; //count of leaves

                archName = 'architectural material';
                typeCount = recordOneType(architectureSet, matExactMap, original, nodes, archName);
                allCount = allCount + typeCount;

                metalName = "metal";
                typeCount = recordOneType(metalSet, matExactMap, original, nodes, metalName);
                allCount = allCount + typeCount;

                mineralName = "mineral";
                typeCount = recordOneType(mineralSet, matExactMap, original, nodes, mineralName);
                allCount = allCount + typeCount;

                ecoName = "ecological";
                typeCount = recordOneType(ecoSet, matExactMap, original, nodes, ecoName);
                allCount = allCount + typeCount;

                dailyName = "daily life object";
                typeCount = recordOneType(dailyLifeSet, matExactMap, original, nodes, dailyName);
                allCount = allCount + typeCount;

                kilnName = "kiln product";
                typeCount = recordOneType(kilnSet, matExactMap, original, nodes, kilnName);
                allCount = allCount + typeCount;

                original.push({
                  'name' : 'root',
                  'parent' : '',
                  'count' : allCount,
                  'leave' : allCount
                })

                console.log('allCount: ' + allCount);
                console.log('original: ');
                console.log(original);


                root = d3.stratify()
              .id(function(row) { return row.name; })
              .parentId(function(row) {
              return row.parent;
              })
              (original);

              console.log("root: ");
              console.log(root);


              return root;
              }


                  function cirtree(data) {
                    const graphTitle1 = g.artItems.append('text')
                      .text('Hierarchical Relationship');
                      graphTitle1.attr("id", 'graphTitle');
                      graphTitle1.attr('dx', 20);
                      graphTitle1.attr('dy', 100);
                      graphTitle1.attr('font-size', '23px');

                   const graphTitle2 = g.artItems.append('text')
                     .text('of Materials Types Used on');
                     graphTitle2.attr("id", 'graphTitle');
                     graphTitle2.attr('dx', 20);
                     graphTitle2.attr('dy', 130);
                     graphTitle2.attr('font-size', '23px');

                   const graphTitle3 = g.artItems.append('text')
                     .text('Art Items in Range of ');
                     graphTitle3.attr("id", 'graphTitle');
                     graphTitle3.attr('dx', 20);
                     graphTitle3.attr('dy', 160);
                     graphTitle3.attr('font-size', '23px');

                     const graphTitle5 = g.artItems.append('text')
                       .text('San Francisco');
                       graphTitle5.attr("id", 'graphTitle');
                       graphTitle5.attr('dx', 20);
                       graphTitle5.attr('dy', 190);
                       graphTitle5.attr('font-size', '23px');





                        data.sort(function(a, b) {
                          return b.height - a.height || b.count - a.count;
                        });

                        let layout = d3.tree().size([2 * Math.PI, (diameter / 2) - pad]);

                        layout(data);

                        data.each(function(node) {
                          node.theta = node.x;
                          node.radial = node.y;

                          var point = toCartesian(node.radial, node.theta);
                          node.x = point.x;
                          node.y = point.y;
                        });

                        let plot = svg.append("g")
                          .attr("id", "TreePlot")
                          .attr("transform", translate(pad + 90, pad));

                          let line = d3.line()
                            .curve(d3.curveLinear)
                            .x(d => d.x + 900)
                            .y(d => d.y + 330);

                          let generator = function(node) {
                            return line([node.source, node.target]);
                          }

                        drawLinks(plot.append("g"), data.links(), generator);
                        drawNodes(plot.append("g"), data.descendants(), true);
                        console.log(data.descendants());
                        return svg.node();
                      }

                      function drawLinks(g, links, generator) {
                        let paths = g.selectAll('path')
                          .data(links)
                          .enter()
                          .append('path')
                            .attr('d', generator)
                            .attr('class', 'link')
                            .style('stroke','silver')
                            .style("fill-opacity", "0.8");
                      }

                      function drawNodes(g, nodes, raise) {

                        let circles = g.selectAll('circle')
                          .data(nodes, node => node.data.name)
                          .enter()
                          .append('circle')
                            .attr('r', r)
                            .attr('cx', d => d.x + 900)
                            .attr('cy', d => d.y + 330)
                            .attr('id', d => d.data.name)
                            .attr('class', 'node')
                            .style('fill', d => color(d.data.count))
                            .style('stroke','silver')
                            .style("stroke-width", 1);

                        setupEvents(g, circles, raise);
                      }


                      function toCartesian(r, theta) {
                        return {
                          x: r * Math.cos(theta),
                          y: r * Math.sin(theta)
                        };
                      }


                      function setupEvents(g, selection, raise) {
                          selection.on("click", function(d) {
                            acsSet = new Set();

                            let datum = d3.select(this).datum();

                            let name = datum.data.name;
                            let ht = datum.height;
                            console.log(name);
                            console.log(datum.height);
                            //height 0 : outer most, height 1: middle layer, height 2: root
                            if(ht == 0 || ht == '0') {
                              arr = matExactMap[name];
                              console.log(arr);
                              for(i=0; i<arr.length;i++) {
                                acs = arr[i]['Accession Number'];
                                acsSet.add(acs);
                              }
                            } else if (ht == 1 || ht == '1') {
                              exactMats = mTypeMap[name];
                              console.log(exactMats);
                              for (var key in exactMats) {
                                  // check if the property/key is defined in the object itself, not in parent
                                  if (exactMats.hasOwnProperty(key)) {
                                      arr = exactMats[key];
                                      for(i=0; i<arr.length;i++) {
                                        acs = arr[i]['Accession Number'];
                                        acsSet.add(acs);
                                      }
                                  }
                              }


                            } else if (ht == 2 || ht == '2') {
                              for(i=0;i<rawDataPlatTableArr.length;i++) {
                                acs = rawDataPlatTableArr[i]['Accession Number'];
                                acsSet.add(acs);
                              }
                            }

                            d3.json(urls.artItems).then(drawArtItems);

                          });

                               selection.on('mouseover.highlight', function(d) {
                                 // https://github.com/d3/d3-hierarchy#node_path
                                 // returns path from d3.select(this) node to selection.data()[0] root node
                                 let path = d3.select(this).datum().path(selection.data()[0]);
                          //       console.log(path);
                                 // select all of the nodes on the shortest path
                                 let update = selection.data(path, nodes => nodes.id);

                                 // highlight the selected nodes
                                 update.classed('selected', true);

                                 if (raise) {
                                   update.raise()
                                   .style("stroke", "#e68a00")
                                   .style("stroke-width", 5);
                                 }
                               });

                               selection.on('mouseout.highlight', function(d) {
                                 let path = d3.select(this).datum().path(selection.data()[0]);
                                 let update = selection.data(path, node => node.data.name);
                                 update.classed('selected', false);
                                 update.style("stroke", "silver")
                                 .style("stroke-width", 1);
                               });

                               // show tooltip text on mouseover (hover)
                               selection.on('mouseover.tooltip', function(d) {
                                 showTooltip(g, d3.select(this));
                               });

                               // remove tooltip text on mouseout
                               selection.on('mouseout.tooltip', function(d) {
                                 g.select("#tooltip").remove();
                               });
                             }



                             numberFormat = d3.format(".3~s");
                             function showTooltip(g, node) {
                                       let gbox = g.node().getBBox();     // get bounding box of group BEFORE adding text
                                       let nbox = node.node().getBBox();  // get bounding box of node

                                       // calculate shift amount
                                       let dx = nbox.width / 2;
                                       let dy = nbox.height / 2;

                                       // retrieve node attributes (calculate middle point)
                                       let x = nbox.x + dx;
                                       let y = nbox.y + dy;

                                       // get data for node
                                       let datum = node.datum();

                                       let name = datum.data.name;
                                       let count = datum.data.count;

                                       let text = `${name}, ${count}`;

                                       // create tooltip
                                       let tooltip = g.append('text')
                                         .text(text)
                                         .attr('x', x)
                                         .attr('y', y)
                                         .attr('dy', -dy - 4) // shift upward above circle
                                         .attr('text-anchor', 'middle') // anchor in the middle
                                         .attr('id', 'tooltip')
                                         .style('fill','#e68a00')
                                         .style('font-size', '22px');

                                       // it is possible the tooltip will fall off the edge of the
                                       // plot area. we can detect when this happens, and set the
                                       // text anchor appropriately

                                       // get bounding box for the text
                                       let tbox = tooltip.node().getBBox();

                                       // if text will fall off left side, anchor at start
                                       if (tbox.x < gbox.x) {
                                         tooltip.attr('text-anchor', 'start');
                                         tooltip.attr('dx', -dx); // nudge text over from center
                                       }
                                       // if text will fall off right side, anchor at end
                                       else if ((tbox.x + tbox.width) > (gbox.x + gbox.width)) {
                                         tooltip.attr('text-anchor', 'end');
                                         tooltip.attr('dx', dx);
                                       }

                                       // if text will fall off top side, place below circle instead
                                       if (tbox.y < gbox.y) {
                                         tooltip.attr('dy', dy + tbox.height);
                                       }
                                     }


                                     function recordOneType(typeSet, matExactMap, original, nodes, typeName) {
                                       typeCount = 0;
                                       typeSetSize = typeSet.size;
                                       var typeItr = typeSet.entries();
                                       for(i=0;i<typeSetSize;i++){
                                         exactMaterial = typeItr.next().value[0];
                                         nodes.add(exactMaterial);

                                         exactList = [];
                                         exactList = matExactMap[exactMaterial];
                                     //         console.log(exactMaterial);
                                             //  console.log(exactList);
                                         aitCount = exactList.length;

                                         original.push({
                                           'name' : exactMaterial,
                                           'parent' : typeName,
                                           'count' : aitCount,
                                           'leave' : 1
                                         })
                                         typeCount = typeCount + aitCount;
                                       }

                                       original.push({
                                         'name' : typeName,
                                         'parent' : 'root',
                                         'count' : typeCount,
                                         'leave' : typeCount
                                       })

                                       return typeCount;
                                     }

                                     function getTimeIntervalIndex(year) {
                                       //every 25 years
                                       //0: 1811-1835
                                       //1: 1836-1860
                                       //2: 1861-1885
                                       //3: 1886-1910
                                       //4: 1911-1935
                                       //5: 1936-1960
                                       //6: 1961-1985
                                       //7: 1986-2010
                                       //8: 2011-2035
                                       var yearValue = parseInt(year);

                                       var diff = yearValue - 1811;
                                       if(diff < 25) {
                                         return 0; //0: 1811-1835
                                       } else if(diff >= 25 && diff < 50){
                                         return 1; //1: 1836-1860
                                       } else if(diff >= 50 && diff < 75) {
                                         return 2; //2: 1861-1885
                                       } else if (diff >= 75 && diff < 100) {
                                         return 3; //3: 1886-1910
                                       } else if(diff >= 100 && diff < 125) {
                                         return 4;
                                       } else if(diff >= 125 && diff < 150) {
                                         return 5;
                                       } else if (diff >= 150 && diff < 175) {
                                         return 6;
                                       } else if (diff >= 175 && diff < 200) {
                                         return 7;
                                       } else if (diff >= 200 && diff < 225) {
                                         return 8;
                                       }

                                       return 9; //8 is for unkown year...

                                     }


                                     const tip = g.tooltip.append("text").attr("id", "tooltip");
                                     tip.attr("text-anchor", "end");
                                     tip.attr("dx", -5);
                                     tip.attr("dy", -5);
                                     tip.style("visibility", "hidden");

                                     // add details widget
                                     // https://bl.ocks.org/mbostock/1424037
                                     const details = g.details.append("foreignObject")
                                       .attr("id", "details")
                                       .attr("width", 1100)
                                       .attr("height", 260)
                                       .attr("x", 168)
                                       .attr("y", 600);

                                     const body = details.append("xhtml:body")
                                       .style("text-align", "left")
                                       .style("background", "none")
                                       .html("<p>N/A</p>");

                                     details.style("visibility", "hidden");
                                     // setup projection
                                     // https://github.com/d3/d3-geo#geoConicEqualArea
                                     const projection = d3.geoConicEqualArea();
                                     projection.parallels([37.692514, 37.840699]);
                                     projection.rotate([122, 0]);

                                     // setup path generator (note it is a GEO path, not a normal path)
                                     const path = d3.geoPath().projection(projection);

                                     function drawBasemap(json) {
                                       console.log("basemap", json);
                                       jsonInputArray = [];

                                       const basemap = g.basemap.selectAll("path.land")
                                         .data(json.features)
                                         .enter()
                                         .append("path")
                                         .attr("d", path)
                                         .attr("class", "land");

                                       const outline = g.outline.selectAll("path.neighborhood")
                                           .data(json.features)
                                           .enter()
                                           .append("path")
                                           .attr("d", path)
                                           .attr("class", "neighborhood")
                                           .each(function(d) {
                                             // save selection in data for interactivity
                                             // saves search time finding the right outline later
                                             d.properties.outline = this;
                                           });

                                       // add highlight
                                       basemap.on("mouseover.highlight", function(d) {
                                         d3.select(d.properties.outline).raise();
                                         d3.select(d.properties.outline).classed("active", true);
                                       })
                                       .on("mouseout.highlight", function(d) {
                                         d3.select(d.properties.outline).classed("active", false);
                                       });

                                       // add tooltip
                                 /*      basemap.on("mouseover.tooltip", function(d) {
                                         tip.text(d.properties.nhood);
                                         tip.style("visibility", "visible");
                                       })
                                       .on("mousemove.tooltip", function(d) {
                                         const coords = d3.mouse(g.basemap.node());
                                         tip.attr("x", coords[0]);
                                         tip.attr("y", coords[1]);
                                       })
                                       .on("mouseout.tooltip", function(d) {
                                         tip.style("visibility", "hidden");
                                       });
                                       */
                                     }


                                     function drawStreets(json) {
                                       console.log("streets", json);

                                       // only show active streets
                                       const streets = json.features.filter(function(d) {
                                         return d.properties.active;
                                       });

                                       console.log("removed", json.features.length - streets.length, "inactive streets");

                                       g.streets.selectAll("path.street")
                                         .data(streets)
                                         .enter()
                                         .append("path")
                                         .attr("d", path)
                                         .attr("class", "street");
                                     }

                                     function drawArtItems(json) {


                                       d3.selectAll("#allSymbols").remove();
                                       console.log('JSON for art items: ^^^^^^^^^^^^^^^^^^^');
                                       console.log(json);
                                       //if specific requirement, change set, otherwise use the default set...
                                       //according to queryReq, change the set range/content

//TODO change way of adjusting range of acsSet!!


                                       console.log("!!!!!!!!!!!!!!!!!!!!!!!current range: ");
                                       console.log(YearChosen + ", " + MTypeChosen +": ");
                                       console.log(acsSet);

                                       // loop through and add projected (x, y) coordinates
                                       // (just makes our d3 code a bit more simple later)
                                       count = 0;
                                       json.forEach(function(d) {
                                         if(!isNaN(d.latitude) && !isNaN(d.longitude)) {
                                           count++;
                                           const latitude = parseFloat(d.latitude);
                                           const longitude = parseFloat(d.longitude);
                                           const pixels = projection([longitude, latitude]);

                                           d.x = pixels[0];
                                           d.y = pixels[1];
                                         } else {
                                           d.x = -10;
                                           d.y = -10;
                                         }

                                         jsonInputArray.push({
                                           'Display Title': d.display_title,
                                           'Artist': d.artist,
                                           'Completion Year': d.creation_date,
                                           'Accession Number': d.accession_number,
                                           'Medium Detail': d.medium,
                                           'Latitude': d.latitude,
                                           'Longitude': d.longitude
                                         })
                                       });

                                       // locMap[locString]    locString = row.Latitude + "&" + row.Longitude;   locAcsSet = locMap[locString]   locAcsSet.size



                                       const symbols = g.artItems.selectAll("circle")
                                         .data(json)
                                         .enter()
                                         .filter(d => (acsSet.has(d.accession_number)))
                                         .append("circle")
                                         .attr("id", "allSymbols")
                                         .attr("cx", function(d) { if(!isNaN(d.x))return d.x;})
                                         .attr("cy", function(d) { if(!isNaN(d.y))return d.y;})
                                         .attr("r", function(d) {
                                           locStr = d.latitude + "&" + d.longitude;

                                           if(locMap[locStr]) {
                                             locSet = locMap[locStr];
                                             //both in locSet and acsSet
                                             var intersectionSet = locSet.intersection(acsSet);
                                             caseCount = intersectionSet.size;

                                             radius = (caseCount - 1) * 0.36 + 5;
                                           } else {
                                             radius = 5;
                                           }
                                           return radius;
                                         })
                                         .attr("class", "symbol")
                                         .style("fill", "#e6b800");
                                 //      symbols.filter(d => (acsSet.has(d.AccessionNumber))).style("fill", "pink");
                                 //      console.log(d.AccessionNumber);
                                 //      <g id="symbolList" pointer-events="none"></g>

                                 symbols.on("click", function(d) {

                                       console.log('clicking symbol... ' + d.latitude + ", " + d.longitude);
                                       len = jsonInputArray.length;
                                       console.log('jsonInputArray');
                                       console.log(jsonInputArray);
                                       let resultSet = new Set();

                                       let chosenSymbolList = [];
                                       console.log('chosenSymbolList: ');
                                       console.log(chosenSymbolList);

                                       for(i=0;i<len;i++) {
                                         if(jsonInputArray[i]['Latitude'] == d.latitude
                                         && jsonInputArray[i]['Longitude'] == d.longitude
                                         && !resultSet.has(jsonInputArray[i]['Accession Number'])
                                         && acsSet.has(jsonInputArray[i]['Accession Number'])) {

                                           resultSet.add(jsonInputArray[i]['Accession Number']);
                                           chosenSymbolList.push({
                                             'Display Title': jsonInputArray[i]['Display Title'],
                                             'Artist': jsonInputArray[i]['Artist'],
                                             'Completion Year': jsonInputArray[i]['Completion Year'],
                                             'Accession Number': jsonInputArray[i]['Accession Number'],
                                             'Medium Detail': jsonInputArray[i]['Medium Detail']
                                           })
                                         }
                                       }
                                       console.log('chosenSymbolList: ');
                                       console.log(chosenSymbolList);
                                       //chosenSymbolList display!!

                                       htmlSymbolItemList = `
                                       <title> Art Items at ${d.street_address}</title>
                                       <div style="overflow:auto">
                                         <table border="0" cellspacing="0" cellpadding="2"  style="height: 200px">
                                         <tbody>
                                         <tr>
                                            <th>Display Title  </th>
                                            <th>Artist  </th>
                                            <th>Completion Year  </th>
                                            <th>Medium Detail  </th>
                                            <th>Accession Number  </th>
                                        </tr>`;

                                      for(j=0;j<chosenSymbolList.length;j++) {
                                        rowInfo = `<tr>
                                          <td>${chosenSymbolList[j][['Display Title']]}  </td>
                                          <td>${chosenSymbolList[j]['Artist']}  </td>
                                          <td>${chosenSymbolList[j]['Completion Year']}  </td>
                                          <td>${chosenSymbolList[j]['Medium Detail']}  </td>
                                          <td>${chosenSymbolList[j]['Accession Number']}  </td>
                                        </tr>`;
                                        htmlSymbolItemList = htmlSymbolItemList + rowInfo;
                                      }


                                      htmlSymbolItemList = htmlSymbolItemList
                                      +` </tbody>
                                       </table>
                                       </div>`;

                                       var win = window.open("", "", "toolbar=no,location=no,directories=no,status=no,menubar=no,scrollbars=yes,resizable=yes,width=980,height=300,top="+(screen.height-400)+",left="+(screen.width-840));
                                       win.document.body.innerHTML = htmlSymbolItemList;

                                       symbolChosen = true;

                                 });


                                       symbols.on("mouseover", function(d) {
                                         d3.select(this).raise();
                                         d3.select(this).classed("active", true);
                                         locStr = d.latitude + "&" + d.longitude;

                                         if(locMap[locStr]) {
                                           locSet = locMap[locStr]
                                           itemCount = locSet.size;

                                           locSet = locMap[locStr];
                                           //both in locSet and acsSet
                                           var intersectionSet = locSet.intersection(acsSet);
                                           caseCount = intersectionSet.size;
                                         } else {
                                           itemCount = 1;
                                         }

                                         // use template literal for the detail table
                                         // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Template_literals
                                         htmlSymbolDetail = `
                                           <table border="0" cellspacing="0" cellpadding="2">
                                           <tbody>
                                           <tr>
                                             <th>Count of Art Item(s):</th>
                                             <td>${caseCount}</td>
                                           </tr>
                                           <tr>
                                             <th>Address:</th>
                                             <td>${d.street_address}</td>

                                             <th>Location Description:</th>
                                             <td>${d.location_description}</td>

                                             <th>Latitude, Longitude:</th>
                                             <td>${d.latitude}, ${d.longitude}</td>
                                           </tr>


                                           `;
                                         htmlSymbolDetail  = htmlSymbolDetail +`

                                         </tbody>
                                         </table>`;

                                         body.html(htmlSymbolDetail);
                                         details.style("visibility", "visible");
                                       });


                                       symbols.on("mouseout", function(d) {
                                         d3.select(this).classed("active", false);
                                         details.style("visibility", "hidden");
                                       });

                                     }

                                               function line() {
                                                 d3.lineRadial()
                                                   .curve(d3.curveBundle.beta(0.85))
                                                   .radius(d => d.y)
                                                   .angle(d => d.x)
                                               }

                                               function id(node) {
                                                 return `${node.parent ? id(node.parent) + "." : ""}${node.data.name}`;
                                               }




                                               function translate(x, y) {
                                                 return "translate(" + String(x) + "," + String(y) + ")";
                                               }

                                               Set.prototype.intersection = function(otherSet){
                                                   // creating new set to store intersection
                                                   var intersectionSet = new Set();

                                                   // Iterate over the values
                                                   for(var elem of otherSet)
                                                   {
                                                       // if the other set contains a
                                                       // similar value as of value[i]
                                                       // then add it to intersectionSet
                                                       if(this.has(elem))
                                                           intersectionSet.add(elem);
                                                   }

                                               // return values of intersectionSet
                                               return intersectionSet;
                                             }
                                               function drawColorLegend() {
                                                      const legendWidth = 200;
                                                      const legendHeight = 20;

                                                      // place legend in its own group
                                                      const group = svg.append("g");
                                                      group.attr('id', 'color-legend');

                                                      // shift legend to appropriate position
                                                      group.attr('transform', translate(width - 220 - legendWidth - 30, 0));

                                                      const title = group.append('text')
                                                        .attr('class', 'axis-title')
                                                        .text('Count of Current Material(Type) Being Used by Art Items');
                                                        title.attr('dx', -143);
                                                        title.attr('dy', 29);

                                                      const legendLabelMin = group.append('text')
                                                        .text('0')
                                                        .attr('dx', -95)
                                                        .attr('dy', 55);

                                                      const legendLabelMax = group.append('text')
                                                        .text('1458')
                                                        .attr('dx', 135)
                                                        .attr('dy', 55);

                                                      // lets draw the rectangle, but it won't have a fill just yet
                                                      const colorbox = group.append('rect')
                                                        .attr('x', -75)
                                                        .attr('y', 39)
                                                        .attr('width', legendWidth)
                                                        .attr('height', legendHeight)
                                                        .style('stroke', 'silver');

                                                      // get the domain first (we do not want the middle value from the diverging scale)
                                                      const colorDomain = [d3.min(color.domain()), d3.max(color.domain())];
                                              //        const color = d3.scaleSequential(d3.interpolateGnBu);

                                              //        color.domain([0,235,471,706,942]);
                                                      // add a new scale to go from color tick to percent
                                                      percent = d3.scaleLinear()
                                                        .range([0, 100])
                                                        .domain(colorDomain);

                                                      // we have to first add gradients
                                                      const defs = svg.append('defs');

                                                      // add a color stop per data tick
                                                      // input  (ticks)   : [0.2, ..., 100, ..., 200.3]
                                                      // output (percents): [  0, ..., 50, ..., 100]
                                                      defs.append('linearGradient')
                                                        .attr('id', 'gradient')
                                                        .selectAll('stop')
                                                        .data(color.ticks())
                                                        .enter()
                                                        .append('stop')
                                                        .attr('offset', d => percent(d) + '%')
                                                        .attr('stop-color', d => color(d));

                                                      // draw the color rectangle with the gradient
                                                      colorbox.attr('fill', 'url(#gradient)');


                                                    }
</script>


<h3> Encoding</h3>
<p>On the proportional symbol map, the symbols are the locations of art items. Since sometimes there are multiple artworks at the same place, the count of art items is encoded by the size of the circle. Larger size of the circle symbol means more count of art items in that location. For the node-link diagram, the second layer of nodes under root are the same set of types as in the heatmap, and there are more specific subtypes under these 6 main types. The color on those nodes represents how many that type of material used, that darker blue means more time of using.
</p>

<h3> Interactivity</h3>
<p> For the node-link diagram, hover each node to see the material type name and its count of being used. Clicking a node can filter the symbols on the map to only show art items that fit in the type specified on that node. To resume the overall view, click the root node.
For the symbol map, hover on a symbol to see how many art items are in that location, and click a symbol to get a pop up window for a table of information of artworks on that location in that query range.

</p>


<h3>Findings </h3>
<p> <strong>Question: </strong> What is the relationship of these material types used in artworks? What more specific types of material are used and how frequently were they used?

 </br>
  <strong>Answer: </strong>  As in the node-link diagram, there are over 100 of subtypes in total under those 6 main types, such as steel and bronze under metal, and clay, glass and porcelain under kiln product. We can see that the traditional materials like bronze or concrete were used a lot in artworks, but there are also some daily life objects that were surprisingly used in the art items. For example, cables and egg tempera were mediums of some of the artworks. This visualization conveys some fun facts especially for people who are not experts on art, also the symbol map actually provides the information about where to look at those novel artworks.
 </p>


 <h3> Data Wrangling</h3>
 <p> For the classification of material types, all mediums of each art item would be splited up and form an array(since in most case there are multiple materials used in one art item), and each material as key in a map, could aggregate count of occurence in the art items. There are 6 main types of materials, and there is a map keeps records of counts for each material type, and an array of subtypes under it.
  To form the hierarchical data structure, each type and subtype would be recorded as node names into an array, with the root as material type's parent node, and mateiral type as subtype's parent nodes. With d3.stratify() on this array, hierarchical data structure would be formed.
  Moreover, for the filtering on map visualization, the latitude + longitude would also work as keys in a map that keeps locations, to record information of all the art items at the same location.
  There is also an array works as a plain table for arbitrary query on original data without any requirement on information of current key-value pairs.</p>

      </div>
      <!-- End page content -->
    </div>
  </section>

  <!-- Page footer -->
  <!-- https://bulma.io/documentation/layout/footer/ -->
  <footer class="footer">
    <div class="content has-text-centered is-size-7">
      <p>
        <a href="#top">
          <span class="fas fa-arrow-up"></span>
          <span class="has-text-weight-medium">Back to Top</span>
        </a>
      </p>

      <p>
        <a href="https://github.com/usf-cs360-spring2020/project-alexziweiwang" class="button is-small" style="padding-left: 1em; padding-right: 1em;" target = _blank>
          <i class="fab fa-github-alt"></i>&nbsp;<strong>Github</strong>
        </a>

        <a href="https://fontawesome.com/" class="button is-small" style="padding-left: 1em; padding-right: 1em;">
          <i class="fab fa-font-awesome"></i>&nbsp;<strong>FontAwesome</strong>
        </a>

        <a href="https://bulma.io" class="button is-small">
          <img src="https://bulma.io/images/made-with-bulma--semiblack.png" alt="Made with Bulma" width="128" height="24">
        </a>
      </p>
    </div>
  </footer>
  <!-- End page footer -->
  </body>

</html>
